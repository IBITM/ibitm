<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 263.丑数序列</title>
    <link href="/2020/10/27/LeetCode-263-%E4%B8%91%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <url>/2020/10/27/LeetCode-263-%E4%B8%91%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="丑数序列"><a href="#丑数序列" class="headerlink" title="丑数序列"></a>丑数序列</h2><p>丑数问题可以归结为序列问题，而序列问题中的元素往往存在一些递推关系，使用编程来解决序列问题往往可以考察程序员对于问题特征的思考和算法实现能力。</p><a id="more"></a><h2 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a><a href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a></h2><blockquote><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p><strong>示例 1:</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">6</span><span class="hljs-string">输出:</span> <span class="hljs-literal">true</span><span class="hljs-string">解释:</span> <span class="hljs-number">6</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span> <span class="hljs-string">×</span> <span class="hljs-number">3</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">8</span><span class="hljs-string">输出:</span> <span class="hljs-literal">true</span><span class="hljs-string">解释:</span> <span class="hljs-number">8</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span> <span class="hljs-string">×</span> <span class="hljs-number">2</span> <span class="hljs-string">×</span> <span class="hljs-number">2</span></code></pre><p><strong>示例 3:</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">14</span><span class="hljs-string">输出:</span> <span class="hljs-literal">false</span> <span class="hljs-string">解释:</span> <span class="hljs-number">14</span> <span class="hljs-string">不是丑数，因为它包含了另外一个质因数</span> <span class="hljs-number">7</span><span class="hljs-string">。</span></code></pre></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isUgly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        # 吐槽一下，题目里说了正整数，结果测试用例里给了一个 0         <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">while</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)            num /= <span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span> (num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)            num /= <span class="hljs-number">3</span>;        <span class="hljs-keyword">while</span> (num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)            num /= <span class="hljs-number">5</span>;        <span class="hljs-keyword">return</span> num == <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></h2><p>编写一个程序，找出第 <code>n</code> 个丑数。</p><p>丑数就是质因数只包含 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">10</span>输出: <span class="hljs-number">12</span>解释: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span> 是前 <span class="hljs-number">10</span> 个丑数。</code></pre><p><strong>说明:</strong>  </p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><p><strong>思路：</strong></p><p>为什么说丑数问题是一个序列问题呢？</p><p>因为第 n 个丑数肯定是由比 n 小的丑数 <em> 2、</em> 3 或者 *5 得到。</p><p>那我们怎么通过开始的丑数来获得有序的丑数序列呢？</p><p><img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/LeetCode/丑数序列.png?raw=true" alt="丑数序列"></p><p>我们设置 3 个指针，红色每次 <em>2，绿色每次 \</em>3，蓝色每次 *5</p><p><strong>Step1</strong></p><p>我们可以由 1*2 得到 2 或者 1*3 得到 3 再或者 1* 5 = 5</p><p>我们选择三者中的最小值 2，并且红色指针向前走一步</p><p><strong>Step2</strong></p><p>我们可以由 1*3 = 3 或者 1* 5 = 5 再或者 2*2= 4</p><p>我们选择三者中的最小值 3，并且绿色指针向前走一步</p><p><strong>Step2</strong></p><p>我们可以由 1* 5 = 5 或者 2*2= 4 再或者 2*3 = 6</p><p>我们选择三者中的最小值 4，并且红色指针向前走一步</p><p>以此类推</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        help[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> i2 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> i3 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> i5 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (index &lt; n) &#123;            help[index] = Math.min(<span class="hljs-number">2</span> * help[i2], Math.min(<span class="hljs-number">3</span> * help[i3], <span class="hljs-number">5</span> * help[i5]));            <span class="hljs-keyword">if</span> (help[index] == <span class="hljs-number">2</span> * help[i2])                i2++;            <span class="hljs-keyword">if</span> (help[index] == <span class="hljs-number">3</span> * help[i3])                i3++;            <span class="hljs-keyword">if</span> (help[index] == <span class="hljs-number">5</span> * help[i5])                i5++;            index++;        &#125;        <span class="hljs-keyword">return</span> help[index - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找最近的回文数</title>
    <link href="/2020/10/26/LeetCode%20564.%20%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2020/10/26/LeetCode%20564.%20%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="564-寻找最近的回文数"><a href="#564-寻找最近的回文数" class="headerlink" title="564. 寻找最近的回文数"></a><a href="https://leetcode-cn.com/problems/find-the-closest-palindrome/">564. 寻找最近的回文数</a></h1><blockquote><p>给定一个整数 n ，你需要找到与它最近的回文数（不包括自身）。</p><p>“最近的”定义为两个整数<strong>差的绝对值</strong>最小。</p><p><strong>示例 1:</strong></p><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;123&quot;</span>输出: <span class="hljs-string">&quot;121&quot;</span></code></pre><p><strong>注意:</strong></p><ol><li><strong>n</strong> 是由字符串表示的正整数，其长度不超过18。</li><li>如果有多个结果，返回最小的那个。</li></ol></blockquote><h2 id="拓展知识点-Java-基本数据结构的表示范围"><a href="#拓展知识点-Java-基本数据结构的表示范围" class="headerlink" title="拓展知识点-Java 基本数据结构的表示范围"></a>拓展知识点-Java 基本数据结构的表示范围</h2><div class="table-container"><table><thead><tr><th>类型</th><th>存储</th><th>表示范围</th><th>定义变量时的特殊处理</th></tr></thead><tbody><tr><td>byte</td><td>1B</td><td>[-128 ,127]</td><td>末尾加B</td></tr><tr><td>short</td><td>2B</td><td>[-32768,32767]</td><td>末尾加S</td></tr><tr><td>int</td><td>4B</td><td>[-2147483648,2147483647]（20亿左右，10位十进制数）</td><td>无</td></tr><tr><td>long</td><td>8B</td><td>[-9223372036854774808,9223372036854774807]（19位十进制数）</td><td>末尾加L</td></tr></tbody></table></div><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最近的回文数可能比当前的数 n 大或者小，所以这个题目需要比较比 n 大的最小回文数和比 n 小的最大回文数到 n 的距离来确定最近的回文数是哪一个。</p><p>我们再考虑如何从 n 如何得到这 2 个回文数。</p><p>我们观察 n = 123，当我们从中间位置反转时我们可以直接得到一个回文数 121，121 就是比 123 小的最大回文数。</p><p>当时 n  = 12312 的时候，我们从中间位置反转可以得到 12321 ，这时候 12321 就是比 12312 大的最小回文数。</p><p>当 n 的位数为偶数时，同样可以得到类似的结论。</p><p>以上的规律并不能实质性的帮我们解决问题，我们还是需要想出从 n 得到这两个回文数的办法。</p><p>我们再回到 n = 12312，我们可以知道距离它最近的 2 个回文是 12321 和 12221</p><p>12321 可以由反转直接得到，12221 可以由 12312 中间位 -1 之后在反转得到。</p><p>当我们 + 或者 - 的时候一定要考虑溢出和结尾的情况</p><p>当 n = 101 时，99 可以由 91 反转得到</p><p>当 n = 12345 的时候，12421 可以由 12445 反转得到</p><p>当 n = 99 的时候，101 可以由 100 反转得到</p><p>这时候知道为什么题目里面会规定 n  的长度不会超过 18 了吧，因为 long 能表示 19 位，我们在计算过程中会出现进位的情况。</p><p>如何处理 n 的位数奇偶和一些边界情况的处理，就只能细扣代码了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">nearestPalindromic</span><span class="hljs-params">(String n)</span> </span>&#123;Long num = Long.valueOf(n);Long raw = getRawPalindrome(n);Long big = raw &gt; num ? raw : getBigPalindrome(raw);Long small = raw &lt; num ? raw : getSmallPalindrome(raw);<span class="hljs-keyword">return</span> String.valueOf(big - num &gt;= num - small ? small : big);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">getRawPalindrome</span><span class="hljs-params">(String n)</span> </span>&#123;<span class="hljs-keyword">char</span>[] chs = n.toCharArray();<span class="hljs-keyword">int</span> len = chs.length;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">2</span>; i++) &#123;chs[len - <span class="hljs-number">1</span> - i] = chs[i];&#125;<span class="hljs-keyword">return</span> Long.valueOf(String.valueOf(chs));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">getBigPalindrome</span><span class="hljs-params">(Long raw)</span> </span>&#123;<span class="hljs-keyword">char</span>[] chs = String.valueOf(raw).toCharArray();<span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[chs.length + <span class="hljs-number">1</span>];res[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;res[i + <span class="hljs-number">1</span>] = chs[i];&#125;<span class="hljs-keyword">int</span> size = chs.length;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = (size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (++res[j] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;res[j] = <span class="hljs-string">&#x27;0&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">int</span> offset = res[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;size = res.length;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt;= (size + offset) / <span class="hljs-number">2</span>; i--) &#123;res[i] = res[size - i - offset];&#125;<span class="hljs-keyword">return</span> Long.valueOf(String.valueOf(res));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">getSmallPalindrome</span><span class="hljs-params">(Long raw)</span> </span>&#123;<span class="hljs-keyword">char</span>[] chs = String.valueOf(raw).toCharArray();<span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[chs.length];<span class="hljs-keyword">int</span> size = res.length;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;res[i] = chs[i];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = (size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (--res[j] &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;res[j] = <span class="hljs-string">&#x27;9&#x27;</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (res[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[size - <span class="hljs-number">1</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;res[i] = <span class="hljs-string">&#x27;9&#x27;</span>;&#125;<span class="hljs-keyword">return</span> size == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : Long.parseLong(String.valueOf(res));&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; size / <span class="hljs-number">2</span>; k++) &#123;res[size - <span class="hljs-number">1</span> - k] = res[k];&#125;<span class="hljs-keyword">return</span> Long.valueOf(String.valueOf(res));&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法和数据结构</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 Kafka 核心设计和实践原理</title>
    <link href="/2020/10/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Kafka%20%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E8%B7%B5%E5%8E%9F%E7%90%86/"/>
    <url>/2020/10/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Kafka%20%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E8%B7%B5%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第-4-章-主题和分区"><a href="#第-4-章-主题和分区" class="headerlink" title="第 4 章 - 主题和分区"></a>第 4 章 - 主题和分区</h1><h2 id="4-1-主题的管理"><a href="#4-1-主题的管理" class="headerlink" title="4.1 主题的管理"></a>4.1 主题的管理</h2><p>主题的管理主要是包括主题的创建、修改、删除以及查看主题的元数据，都可以通过 Kafka 提供的 kafka-topics.sh 脚本执行这一些操作。</p><p>这个脚本本质上是调用了 kafka.admin.TopicCommand 类来执行主题管理的操作。</p><p>一般来说，还有 2 种办法可以实现主题的管理</p><ul><li>通过 KafkaAdminClient 的方式（通过发送 CreateTopicRequest 和 DeleteTopicRequest）</li><li>直接修改日志文件和 Zookeeper 节点。Kafka 的日志文件存放在 log.dir 或者 log.dirs 参数所配置的目录下，默认是 /tmp/kafka-logs/。Zoookeeper 中存储着分区的元数据，我们可以通过直接修改 Zookeeper 的节点数据来实现对主题的管理。</li></ul><p>kafka-topics.sh 脚本中的参数</p><div class="table-container"><table><thead><tr><th>参数名称</th><th>释义</th></tr></thead><tbody><tr><td>alter</td><td>用于修改主题，包括分区数和主题的配置</td></tr><tr><td>config</td><td>创建和修改主题时，用于设置主题级别的参数</td></tr><tr><td>create</td><td>创建主题</td></tr><tr><td>delete</td><td>删除主题</td></tr><tr><td>delete-config</td><td>删除主题级别被覆盖的配置</td></tr><tr><td>describe</td><td>查看主题的详细信息</td></tr><tr><td>disable-rack-aware</td><td>创建主题时不考虑机架信息</td></tr><tr><td>help</td><td>打印主题</td></tr><tr><td>list</td><td>罗列出所有的主题</td></tr><tr><td>partition</td><td>创建主题或者增加分区时指定分区数</td></tr><tr><td>replica-assignment</td><td>手动指定分区副本分配方案</td></tr><tr><td>replication-factor</td><td>创建主题时指定副本因子</td></tr><tr><td>topic</td><td>指定主题名字</td></tr><tr><td>topics-with-overrides</td><td>使用 describe 查看主题信息时，展示与默认配置不同的配置</td></tr><tr><td>unavailable-partitions</td><td>使用 describe 查看主题信息时，展示没有 leader 副本的分区</td></tr><tr><td>under-replicated-partitions</td><td>使用 describe 查看主题信息时，展示包含失败副本的分区</td></tr><tr><td>Zookeeper</td><td>指定连接的 Zookeeper 的地址信息</td></tr></tbody></table></div><p>需要先明确一下主题、分区、副本和日志的概念，主题和分区都是提供给上层用户的抽象，而在副本层面或者更确切地说是 Log 层面才有真实的物理存在。</p><p><img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/主题、分区、副本和 Log 之间的关系.png?raw=true" alt="主题、分区、副本和 Log 之间的关系"></p><h3 id="查看主题信息"><a href="#查看主题信息" class="headerlink" title="查看主题信息"></a>查看主题信息</h3><p>我们可以直接通过查看底层的物理存储和 Zookeeper 的节点信息来获取主题下分区的分配方案</p><pre><code class="hljs gradle">ls -al <span class="hljs-regexp">/tmp/</span>kafka-logs/ | <span class="hljs-keyword">grep</span> topic_name</code></pre><p>当我们创建一个主题后，会在 Zookeeper 的 /brokers/topics/ 目录下创建一个同名的实节点（实节点？）</p><pre><code class="hljs awk">get <span class="hljs-regexp">/brokers/</span>topics/topic_name</code></pre><p>但是通用的方法还是通过 kafka-topics.sh 命令，该命令可以与 topics-with-overrides 、unavailable-partitions、under-replicated-partitions 连用来过滤一些数据。</p><pre><code class="hljs shell">bin/kafka-topics.sh --zookeeper localhost:2121/kafka--describe --topic topic_name1, topic_name2, ...</code></pre><p>此外，如果你不知道你具体有哪一些主题，可以使用 list 命令查看有哪一些主题</p><pre><code class="hljs shell">bin/kafka-topics.sh --zookeeper localhost:2121/kafka--list</code></pre><h3 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h3><p>首先，有一个比较重要的 broker 端的参数 auto.create.topics.enabele 默认为 true。当生产者给一个尚未创建的主题发送消息或者当生产者向一个尚未创建的主题发送元数据请求或者读取数据时，都会按照 num.partitions 和 default.replication.factor  的值来创建一个主题。在生产活动中强烈建议该参数设置为 false。</p><p>接下来我们通过 kafka-topics.sh 命令创建主题</p><pre><code class="hljs shell">bin/kafka-topics.sh --zookeeper localhost:2121/kafka--create--topic topic_name1--partitions n--replication-factor m</code></pre><p>该命令同时可以搭配 replica-assignment 来手动指定分区副本的分配方案，这个参数的使用暂时不做讨论。</p><p>另外一个使用比较多的参数是 config，该参数可以覆盖原本的默认配置，比如</p><pre><code class="hljs shell">bin/kafka-topics.sh --zookeeper localhost:2121/kafka--create--topic topic_name1--partitions 1--replication-factor 1--config cleanup.policy=compact--config max.message.bytes=10000</code></pre><p>使用语法就是 <code>--config key=value</code> 的形式。除了主题的分区分配策略可以通过 Zookeeper 节点查看，主题的配置同样可以通过 Zookeeper 查看，对应的节点为 /config/topics/topic_name</p><p>有一个需要特殊注意的点是主题的命名，kafka-topics 节点在创建主题的时候会检测主题名中是否含有 . 或者 _ 。为什么要这多样做呢？因为 Kafka 内部做埋点时会根据主题名命名 metrics 的名字，并且会将 . 转化成 _ 。所以尽量不要在命名主题时，使用 . 。此外，主题名尽量不要以 <strong> 开头，因为以 </strong> 开头在 Kafka 中被视为内部主题。</p><blockquote><p>关于功能升级和重构的思考：</p><ol><li>升级和重构的复杂程度</li><li>升级和重构会不会影响到其他的功能</li></ol></blockquote><h2 id="4-2-初识-KafkaAdminClient"><a href="#4-2-初识-KafkaAdminClient" class="headerlink" title="4.2 初识 KafkaAdminClient"></a>4.2 初识 KafkaAdminClient</h2><p>// to do</p><h2 id="4-3-分区的管理"><a href="#4-3-分区的管理" class="headerlink" title="4.3 分区的管理"></a>4.3 分区的管理</h2><p>// to do</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 包管理基础</title>
    <link href="/2019/12/22/Linux%20%E5%8C%85%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/12/22/Linux%20%E5%8C%85%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>内容参考自 <a href="https://linux.cn/article-8782-1.html">Linux 包管理基础：apt、yum、dnf 和 pkg</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>大多数现代的类 Unix 操作系统都提供了一种<strong>中心化</strong>的机制用来搜索和安装软件。软件通常都是存放在存储库中，并通过包的形式进行分发。处理包的工作被称为包管理。包提供了操作系统的基本组件，以及共享的库、应用程序、服务和文档。</p><p>包管理系统除了安装软件外，它还提供了工具来更新已经安装的包。包存储库有助于确保你的系统中使用的代码是经过审查的，并且软件的安装版本已经得到了开发人员和包维护人员的认可。</p><p>在配置服务器或开发环境时，我们最好了解下包在官方存储库之外的情况。某个发行版的稳定版本中的包有可能已经过时了，尤其是那些新的或者快速迭代的软件。然而，包管理无论对于系统管理员还是开发人员来说都是至关重要的技能，而已打包的软件对于主流 Linux 发行版来说也是一笔巨大的财富。</p><h2 id="包管理系统：简要概述"><a href="#包管理系统：简要概述" class="headerlink" title="包管理系统：简要概述"></a>包管理系统：简要概述</h2><p>大多数包系统都是围绕包文件的集合构建的。包文件通常是一个存档文件，它包含已编译的二进制文件和软件的其他资源，以及安装脚本。包文件同时也包含有价值的元数据，包括它们的依赖项，以及安装和运行它们所需的其他包的列表。</p><p>虽然这些包管理系统的功能和优点大致相同，但打包格式和工具却因平台而异：</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作系统</th><th style="text-align:left">格式</th><th style="text-align:left">工具</th></tr></thead><tbody><tr><td style="text-align:left">Debian</td><td style="text-align:left"><code>.deb</code></td><td style="text-align:left"><code>apt</code>, <code>apt-cache</code>, <code>apt-get</code>, <code>dpkg</code></td></tr><tr><td style="text-align:left">Ubuntu</td><td style="text-align:left"><code>.deb</code></td><td style="text-align:left"><code>apt</code>, <code>apt-cache</code>, <code>apt-get</code>, <code>dpkg</code></td></tr><tr><td style="text-align:left">CentOS</td><td style="text-align:left"><code>.rpm</code></td><td style="text-align:left"><code>yum</code></td></tr><tr><td style="text-align:left">Fedora</td><td style="text-align:left"><code>.rpm</code></td><td style="text-align:left"><code>dnf</code></td></tr><tr><td style="text-align:left">FreeBSD</td><td style="text-align:left">Ports, <code>.txz</code></td><td style="text-align:left"><code>make</code>, <code>pkg</code></td></tr></tbody></table></div><p>Debian 及其衍生版，如 Ubuntu、Linux Mint 和 Raspbian，它们的包格式是 <code>.deb</code>。APT 这款先进的包管理工具提供了大多数常见的操作命令：搜索存储库、安装软件包及其依赖项，并管理升级。在本地系统中，我们还可以使用 <code>dpkg</code> 程序来安装单个的 <code>deb</code> 文件，APT 命令作为底层 <code>dpkg</code> 的前端，有时也会直接调用它。</p><p>最近发布的 debian 衍生版大多数都包含了 <code>apt</code> 命令，它提供了一个简洁统一的接口，可用于通常由 <code>apt-get</code> 和 <code>apt-cache</code> 命令处理的常见操作。这个命令是可选的，但使用它可以简化一些任务。</p><p>CentOS、Fedora 和其它 Red Hat 家族成员使用 RPM 文件。在 CentOS 中，通过 <code>yum</code> 来与单独的包文件和存储库进行交互。</p><p>在最近的 Fedora 版本中，<code>yum</code> 已经被 <code>dnf</code> 取代，<code>dnf</code> 是它的一个现代化的分支，它保留了大部分 <code>yum</code> 的接口。</p><p>FreeBSD 的二进制包系统由 <code>pkg</code> 命令管理。FreeBSD 还提供了 <code>Ports</code> 集合，这是一个存在于本地的目录结构和工具，它允许用户获取源码后使用 Makefile 直接从源码编译和安装包。</p><h2 id="更新包列表"><a href="#更新包列表" class="headerlink" title="更新包列表"></a>更新包列表</h2><p>大多数系统在<strong>本地都会有一个和远程存储库对应的包数据库</strong>，在安装或升级包之前最好更新一下这个数据库。另外，<code>yum</code> 和 <code>dnf</code> 在执行一些操作之前也会自动检查更新。当然你可以在任何时候对系统进行更新。</p><div class="table-container"><table><thead><tr><th style="text-align:left">系统</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:left">Debian / Ubuntu</td><td style="text-align:left"><code>sudo apt-get update</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>sudo apt update</code></td></tr><tr><td style="text-align:left">CentOS</td><td style="text-align:left"><code>yum check-update</code></td></tr><tr><td style="text-align:left">Fedora</td><td style="text-align:left"><code>dnf check-update</code></td></tr><tr><td style="text-align:left">FreeBSD Packages</td><td style="text-align:left"><code>sudo pkg update</code></td></tr><tr><td style="text-align:left">FreeBSD Ports</td><td style="text-align:left"><code>sudo portsnap fetch update</code></td></tr></tbody></table></div><h3 id="更新已安装的包"><a href="#更新已安装的包" class="headerlink" title="更新已安装的包"></a>更新已安装的包</h3><p>在没有包系统的情况下，想确保机器上所有已安装的软件都保持在最新的状态是一个很艰巨的任务。你将不得不跟踪数百个不同包的上游更改和安全警报。虽然包管理器并不能解决升级软件时遇到的所有问题，但它确实使你能够使用一些命令来维护大多数系统组件。</p><p>在 FreeBSD 上，升级已安装的 ports 可能会引入破坏性的改变，有些步骤还需要进行手动配置，所以在通过 <code>portmaster</code> 更新之前最好阅读下 <code>/usr/ports/UPDATING</code> 的内容。</p><div class="table-container"><table><thead><tr><th>Debian / Ubuntu</th><th><code>sudo apt-get upgrade</code></th><th>只更新已安装的包</th></tr></thead><tbody><tr><td></td><td><code>sudo apt-get dist-upgrade</code></td><td>可能会增加或删除包以满足新的依赖项</td></tr><tr><td></td><td><code>sudo apt upgrade</code></td><td>和 <code>apt-get upgrade</code> 类似</td></tr><tr><td></td><td><code>sudo apt full-upgrade</code></td><td>和 <code>apt-get dist-upgrade</code> 类似</td></tr><tr><td>CentOS</td><td><code>sudo yum update</code></td><td></td></tr><tr><td>Fedora</td><td><code>sudo dnf upgrade</code></td><td></td></tr><tr><td>FreeBSD Packages</td><td><code>sudo pkg upgrade</code></td><td></td></tr><tr><td>FreeBSD Ports</td><td><code>less /usr/ports/UPDATING</code></td><td>使用 <code>less</code> 来查看 ports 的更新提示（使用上下光标键滚动，按 q 退出）。</td></tr><tr><td></td><td><code>cd /usr/ports/ports-mgmt/portmaster &amp;&amp; sudo make install &amp;&amp; sudo portmaster -a</code></td><td>安装 <code>portmaster</code> 然后使用它更新已安装的 ports</td></tr></tbody></table></div><h2 id="结论和进一步的阅读"><a href="#结论和进一步的阅读" class="headerlink" title="结论和进一步的阅读"></a>结论和进一步的阅读</h2><p>本指南通过对多个系统间进行交叉对比概述了一下包管理系统的基本操作，但只涉及了这个复杂主题的表面。对于特定系统更详细的信息，可以参考以下资源：</p><ul><li><a href="https://www.digitalocean.com/community/tutorials/ubuntu-and-debian-package-management-essentials">这份指南</a> 详细介绍了 Ubuntu 和 Debian 的软件包管理。</li><li>这里有一份 CentOS 官方的指南 <a href="https://www.centos.org/docs/5/html/yum/">使用 yum 管理软件</a></li><li>这里有一个有关 Fedora 的 <code>dnf</code> 的 <a href="https://fedoraproject.org/wiki/Dnf">wiki 页面</a> 以及一份有关 <code>dnf</code> <a href="https://dnf.readthedocs.org/en/latest/index.html">官方的手册</a></li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-manage-packages-on-freebsd-10-1-with-pkg">这份指南</a> 讲述了如何使用 <code>pkg</code> 在 FreeBSD 上进行包管理</li><li>这本 <a href="https://www.freebsd.org/doc/handbook/">FreeBSD Handbook</a> 有一节讲述了<a href="https://www.freebsd.org/doc/handbook/ports-using.html">如何使用 Ports 集合</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 实践总结</title>
    <link href="/2019/12/21/SQL-%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <url>/2019/12/21/SQL-%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="概念性问题"><a href="#概念性问题" class="headerlink" title="概念性问题"></a>概念性问题</h2><h2 id="实践性问题"><a href="#实践性问题" class="headerlink" title="实践性问题"></a>实践性问题</h2><h2 id="不同表相同字段当进行关联操作时，会发生什么？"><a href="#不同表相同字段当进行关联操作时，会发生什么？" class="headerlink" title="不同表相同字段当进行关联操作时，会发生什么？"></a>不同表相同字段当进行关联操作时，会发生什么？</h2><p>我们现在有 A，B 两个表</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A;  +<span class="hljs-comment">------+</span>| id   |+<span class="hljs-comment">------+</span>|    1 ||    2 ||    3 |+<span class="hljs-comment">------+</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> B;+<span class="hljs-comment">------+</span>| id   |+<span class="hljs-comment">------+</span>|    3 ||    4 ||    5 |+<span class="hljs-comment">------+</span></code></pre><p>当我们进行关联操作时会发生什么呢？</p><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A,B;+<span class="hljs-comment">------+------+</span>| id   | id   |+<span class="hljs-comment">------+------+</span>|    1 |    3 ||    2 |    3 ||    3 |    3 ||    1 |    4 ||    2 |    4 ||    3 |    4 ||    1 |    5 ||    2 |    5 ||    3 |    5 |+<span class="hljs-comment">------+------+</span></code></pre><h3 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h3><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.id = B.id;+<span class="hljs-comment">------+------+</span>| id   | id   |+<span class="hljs-comment">------+------+</span>|    3 |    3 |+<span class="hljs-comment">------+------+</span></code></pre><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A nature <span class="hljs-keyword">join</span> A;+<span class="hljs-comment">------+------+</span>| id   | id   |+<span class="hljs-comment">------+------+</span>|    1 |    1 ||    2 |    1 ||    3 |    1 ||    1 |    2 ||    2 |    2 ||    3 |    2 ||    1 |    3 ||    2 |    3 ||    3 |    3 |+<span class="hljs-comment">------+------+</span></code></pre><p>我们发现，无论是内连接还是外连接，无论是相同表还是不同表，相同字段并不会覆盖。</p><h3 id="两个集合的交、并、差"><a href="#两个集合的交、并、差" class="headerlink" title="两个集合的交、并、差"></a>两个集合的交、并、差</h3><pre><code class="hljs sql"><span class="hljs-comment">-- 并集</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> B;+<span class="hljs-comment">------+</span>| id   |+<span class="hljs-comment">------+</span>|    1 ||    2 ||    3 ||    4 ||    5 |+<span class="hljs-comment">------+</span><span class="hljs-comment">-- 交集</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.id = B.id;+<span class="hljs-comment">------+------+</span>| id   | id   |+<span class="hljs-comment">------+------+</span>|    3 |    3 |+<span class="hljs-comment">------+------+</span><span class="hljs-comment">-- 差集 A-B</span><span class="hljs-keyword">select</span> A.id <span class="hljs-keyword">from</span> A <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.id = B.id <span class="hljs-keyword">where</span> B.id <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>;+<span class="hljs-comment">------+</span>| id   |+<span class="hljs-comment">------+</span>|    1 ||    2 |+<span class="hljs-comment">------+</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Beamer制作幻灯片入门</title>
    <link href="/2019/12/21/%E4%BD%BF%E7%94%A8Beamer%E5%88%B6%E4%BD%9C%E5%B9%BB%E7%81%AF%E7%89%87%E5%85%A5%E9%97%A8/"/>
    <url>/2019/12/21/%E4%BD%BF%E7%94%A8Beamer%E5%88%B6%E4%BD%9C%E5%B9%BB%E7%81%AF%E7%89%87%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h2><p>我们将 presentation slide 叫做演示幻灯片，具体的由来可以参考维基百科 👉 <a href="https://en.wikipedia.org/wiki/Presentation_slide">presentation slide</a></p><p>随着  <a href="https://en.wikipedia.org/wiki/Microsoft_PowerPoint">Microsoft PowerPoint</a> 占领的市场份额越来越大，我们现在直接将 PowerPoint 的概念等同为了幻灯片。</p><p>其实，幻灯片也可以使用 <a href="https://en.wikipedia.org/wiki/Document_markup_language">文档标记语言</a>例如 <a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX</a> 的 <a href="https://en.wikipedia.org/wiki/Beamer(LaTeX">Beamer</a>) 来创建。</p><h2 id="一些资源网站"><a href="#一些资源网站" class="headerlink" title="一些资源网站"></a>一些资源网站</h2><p><a href="https://www.latexstudio.net/archives/2825.html">Beamer 的基本结构</a></p><p><a href="https://www.latexstudio.net/archives/category/tex-slides/beamer-theme-template">Beamer 幻灯片主题模板</a></p><p><a href="https://www.overleaf.com/gallery/tagged/presentation#.Wv7RVIiFPIU">Beamer 模板</a></p><p>有哪些好的 LaTeX 编辑器？ - 黄盼的回答 - 知乎<br><a href="https://www.zhihu.com/question/19954023/answer/676316395">https://www.zhihu.com/question/19954023/answer/676316395</a></p><p><a href="Huang Zhenghua&#39;s home page">黄正华</a> 老师 LaTeX 和 Beamer 资源的分享</p><p>Beamer v3.0 指南 (黄旭华译)    下载地址：<a href="http://static.latexstudio.net/wp-content/uploads/2014/12/beamer_guide-cnbyl00l.pdf">beamer_guide-cnbyl00l</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
      <tag>幻灯片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HR 面注意事项</title>
    <link href="/2019/12/19/HR-%E9%9D%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2019/12/19/HR-%E9%9D%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>本文的大部分来自 <a href="HR通常提的一些面试问题是什么？怎么回答？ - 职研社De圆圆的回答 - 知乎https://www.zhihu.com/question/24192778/answer/631081857">HR通常提的一些面试问题是什么？怎么回答？ - 职研社De圆圆的回答</a></p><h2 id="你最大的缺点是什么？"><a href="#你最大的缺点是什么？" class="headerlink" title="你最大的缺点是什么？"></a>你最大的缺点是什么？</h2><p><strong>问题分析：</strong>考察候选人的自我认知能力，个人优点是否符合岗位要求。</p><p><strong>参考建议：</strong></p><p>第一，不宜说自己没有缺点，只要是人就有缺点，这么说一定会令人反感。</p><p>第二，年轻经验不足、缺乏磨炼、有些着急、对待效率低下的人缺乏耐心等</p><p><strong>根据以上的关键点，缺点参考回复：</strong></p><p>首先，我刚毕业，经验方面不足，我会在工作中积极完成工作，积累各方面经验</p><p>其次，性子急，对待效率低下的人缺乏耐心，但是我平时和别人聊天的时候会控制自己语速和讲话，慢慢培养自己耐心，避免浮躁。（<strong>遵循一个原则避重就轻</strong>）</p><p><strong>Tips：</strong>利用你的优点改正你的缺点，比如，工作追求细节极致，导致项目无法按时完成，通过时间管理，得以解决。一定不能说对应聘岗位的硬伤的缺点，以及无法弥补的缺点。</p><h2 id="面试最难：自我介绍"><a href="#面试最难：自我介绍" class="headerlink" title="面试最难：自我介绍"></a>面试最难：自我介绍</h2><p><strong>参考建议：</strong></p><p>第一，条理清晰，层次分明，突出与岗位要求相吻合的技能、个人所长、行为风格、实际经验等。</p><p>第二，现场表达必须与个人简历所写保持一致。</p><p>第三，控制时间，一般不超过 3 分钟。</p><p>第四，尽量口语化，语言平实可信。</p><p><strong>▲根据以上的关键点，参考回复：</strong></p><p>首先，我叫xxx，xxx大学xxx专业毕业，我在学校获得xxx荣誉（或者证书）……这样的信息（基本信息介绍）</p><p>其次，在工作方面，我在xxx公司实习（或者学校活动），我负责xx工作，为了完成这个工作，我做了xxx努力，最后取得xxx成果，结尾，还可以总结一下通过这次活动或者项目有什么收获。</p><p><strong>关键点，在做了什么努力这部分要体现做的深度</strong>。<strong>（利用STAR法则）</strong></p><p>第三，在大型比赛中取得xxx的成绩，如果没有，可以讲自己参加过的公益类活动，例如支教，敬老院看望爷爷奶奶。(<strong>特殊经历亮点加分项</strong>)</p><p>（ps:最好准备一个1分钟自我介绍，一个3-5 分钟自我介绍，多手准备!!）</p><p><strong>Tips：</strong>在面试前一天，一定一定要熟记自我介绍，自己也可以对着镜子模拟面试情景反复刻意练习自我介绍。这样才能保证面试从容，不紧张。</p><h2 id="你的兴趣爱好？"><a href="#你的兴趣爱好？" class="headerlink" title="你的兴趣爱好？"></a><strong>你的兴趣爱好？</strong></h2><p><strong>问题分析：</strong>了解候选人的心态、性格、价值观、责任感等</p><p>当HR问到兴趣爱好，这时大脑一片空白，一时想不到，拍脑袋回答没什么爱好，或者随便回答，那你就会掉进坑里了。</p><p><strong>参考建议：</strong></p><p>第一，常见的爱好无外乎运动、旅游、听音乐、读书等，比如篮球：团队精神，古典音乐、阅读、书法：细心耐心，旅游：适应能力学习能力，演讲：沟通能力，唱歌、舞蹈：性格外向，沟通能力</p><p>第二，如果有表现突出的文体爱好，例如书法、羽毛球、小提琴、写文章等获得过有关奖项，可以适当加分</p><p>第三，如果热衷社会公益，参与过某些公益组织，为困难人群提供过无私、积极的帮助的，可以突出介绍，可以给面试官留下更好地印象。</p><p>▲<strong>根据以上的关键点，参考回复：</strong></p><p>eg1：写与岗位匹配的爱好，假如是应聘文案类（编辑）岗位，你说你喜欢写文章，发表过文章，还获得奖，加分！加分！（没得奖也不怕给HR看写过的文章，体现你是有潜力的）</p><p>eg2：我喜欢读书，一年读了xx本，收获xxx。</p><p><strong>Tips：</strong>说岗位需求匹配的爱好，有助于工作的爱好；回答要真实，否则HR接着深入一问，容易露馅。</p><h2 id="介绍未来5年职业规划"><a href="#介绍未来5年职业规划" class="headerlink" title="介绍未来5年职业规划"></a>介绍未来5年职业规划</h2><p><strong>问题分析：</strong>考察候选人对自己未来发展的设想、职业生涯的规划能力。</p><p>除非是目标非常明确的人，或者有多年工作经验的职场人，不然很难回答清楚，那么怎么说才能回答好这个问题呢？</p><p>不要说“几年当主管”，”几年当经理”毫无意义。</p><p><strong>参考建议：</strong></p><p>第一，介绍自己认真思考过这个问题，自己的规划是基于目前的实际情况来设计的。</p><p>第二，在工作方面，突出自己打算通过积极完成工作任务，积累各方面的经验，让自己成为这个领域的专业人士，也希望有机会能够带领团队，成为优秀的管理者，为单位做出更大贡献，获得双赢。</p><p>第三，在学习方面，打算在专业领域做进一步学习和研究，将实践经验与专业知识相结合，为自己的职业成长做好铺垫，打好基础<strong>。</strong></p><p><strong>Tips：</strong>回答这个问题强调你稳定性，踏实工作的态度，重点在工作技能方面的提升与内在积累，不要描述外在的东西，比如职位，薪资。</p><h2 id="还有什么要问的吗？"><a href="#还有什么要问的吗？" class="headerlink" title="还有什么要问的吗？"></a><strong>还有什么要问的吗？</strong></h2><p><strong>问题分析：</strong>考察候选人的情商，是否对这个公司或者行业很了解，是否用心准备。</p><p><strong>参考建议：</strong></p><p>第一，可以问本职岗位工作要求、职责。例如，这个部门人员设置是怎么样的。</p><p>第二，可以问公司、公司的业务、体系、行业、客户。</p><p>eg：为了胜任该职位，需要我提前学习哪些技术知识？</p><p>eg：贵公司业务及战略的未来发展？</p><p>eg：团队、公司现在面临的最大挑战是什么？</p><p><strong>Tips：</strong>切忌纠缠薪资，如果回答没问题，HR会误会，你对岗位没有太大兴趣。</p><h2 id="若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？"><a href="#若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？" class="headerlink" title="若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？"></a>若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？</h2><p><strong>问题分析：</strong>考察候选人的时间管理能力。</p><p><strong>参考建议：</strong></p><p>第一，分清任务的轻重缓急，紧急又重要的任务先完成。</p><p>第二，发动团队其他成员，借力完成。</p><p>第三，鼓励老人带新人，提高工作效率。</p><p><strong>Tips：</strong>实在是过重，以上方法全部用上了都不行，可以与领导协商，先完成几成，其他不重要的任务可以缓办。</p><h2 id="希望与怎样的领导共事？"><a href="#希望与怎样的领导共事？" class="headerlink" title="希望与怎样的领导共事？"></a>希望与怎样的领导共事？</h2><p>一类题：希望与怎样的领导合作？怎样处理与领导的关系？</p><p><strong>问题分析：</strong>考察候选人的人际交往能力、主动适应能力。如果你回答：我希望我的上级比较有经验，能够给饿哦一些帮助，陷阱！这样会暴露自己短处。</p><p><strong>参考建议：</strong></p><p>第一，尽量不要提及对领导的具体要求，而应该突出自己会认真向领导学习，尽快熟悉和适应工作环境，主动向领导请教，保质保量完成本职工作。</p><p>第二，如果有做得不到的地方，会诚恳地向领导请教，可以在哪些地方多多改善。这才是一位职业人作为下属应该秉持的工作态度。</p><p><strong>Tips：</strong>切忌一切围绕工作进行，着重谈论对自己有要求，自身努力的方向，千万不要提及前任领导的缺点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2019/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>设计模式</strong>是软件设计中常见问题或者常见应用场景的典型解决方案。 每个模式就像一张蓝图， 你可以通过对其进行定制来解决代码中的特定设计问题。</p><p>发现一个整理比较号的文档 <a href="https://refactoringguru.cn/design-patterns/what-is-pattern">设计模式</a></p><h2 id="模式的分类"><a href="#模式的分类" class="headerlink" title="模式的分类"></a>模式的分类</h2><p>不同设计模式在其复杂程度、 细节层次以及在整个系统中的应用范围等方面各不相同。 我喜欢将其类比于道路的建造： 如果你希望让十字路口更加安全， 那么可以安装一些交通信号灯， 或者修建包含行人地下通道在内的多层互通式立交桥。</p><p>最基础的、 底层的模式通常被称为<em>惯用技巧</em>。 这类模式一般只能在一种编程语言中使用。</p><p>最通用的、 高层的模式是<em>构架模式</em>。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。</p><p>此外， 所有模式可以根据其<em>意图</em>或目的来分类。 本书覆盖了三种主要的模式类别：</p><ul><li><strong>创建型模式</strong>提供创建对象的机制， 增加已有代码的灵活性和可复用性。</li><li><strong>结构型模式</strong>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li><li><strong>行为模式</strong>负责对象间的高效沟通和职责委派。</li></ul><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>单例模式同时解决了两个问题， 所以违反了<a href="https://refactoringguru.cn/didp/principles/solid-principles/srp">单一职责原则</a>：</p><ol><li><p><strong>保证一个类只有一个实例</strong>。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</p><p>它的运作方式是这样的： 如果你创建了一个对象， 同时一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p><p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它<strong>必须</strong>总是返回一个新对象。</p></li></ol><p>客户端甚至可能没有意识到它们一直都在使用同一个对象。</p><ol><li><p><strong>为该实例提供一个全局访问入口 </strong>。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p><p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p><p>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p></li></ol><p>如今， 单例模式已经变得非常流行， 以至于人们会将只解决上文描述中任意一个问题的东西称为<em>单例</em>。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>所有单例的实现都包含以下两个相同的步骤：</p><ul><li>将默认构造函数设为私有， 防止其他对象使用单例类的 <code>new</code>运算符。</li><li>新建一个静态方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</li></ul><p>如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。</p><h4 id="单例模式适用性"><a href="#单例模式适用性" class="headerlink" title="单例模式适用性"></a>单例模式适用性</h4><ol><li><p>如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。</p><p>单例模式禁止通过除了特殊构建方法以外的任何方式来创建自身类对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象</p></li><li><p>如果你需要更加严格地控制全局变量， 可以使用单例模式。</p><p>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p></li></ol><h4 id="经典的实现方法"><a href="#经典的实现方法" class="headerlink" title="经典的实现方法"></a>经典的实现方法</h4><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;          instance = <span class="hljs-keyword">new</span> Singleton();      &#125;      <span class="hljs-keyword">return</span> instance;      &#125;  &#125;</code></pre><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> instance;      &#125;  &#125;</code></pre><h5 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h5><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;                    singleton = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。</p><p>你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。</p><p>在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。</p><p>代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。</p><p>这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。</p><h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><p>a） 为服务类和代理类提供的公共接口或抽象类</p><p>b） 服务类具体实现逻辑，实现或继承接口</p><p>c）  代理类，实现或继承接口，有对服务类实例的引用，调用服务类实例业务的具体实现</p><p>d） 客户端，调用代理类实现对服务类的调用</p><p><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/structure.png" alt="代理设计模式的结构"></p><h4 id="代理模式适用性"><a href="#代理模式适用性" class="headerlink" title="代理模式适用性"></a>代理模式适用性</h4><p>使用代理模式的方式多种多样， 我们来看看最常见的几种。</p><ol><li><p>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</p><p>你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p></li><li><p>访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。代理可仅在客户端凭据满足要求时将请求传递给服务对象。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 相关问题的总结</title>
    <link href="/2019/12/15/Maven%20%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <url>/2019/12/15/Maven%20%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Maven中建立的依赖管理方式基本已成为Java语言依赖管理的事实标准，Maven的替代者Gradle也基本沿用了Maven的依赖管理机制。在Maven依赖管理中，唯一标识一个依赖项是由该依赖项的三个属性构成的，分别是groupId、artifactId以及version。这三个属性可以唯一确定一个组件（Jar包或者War包）。</p><p>其实在Nexus仓库中，一个仓库一般分为public(Release)仓和SNAPSHOT仓，前者存放正式版本，后者存放快照版本。如果在项目配置文件中（无论是build.gradle还是pom.xml）指定的版本号带有’-SNAPSHOT’后缀，比如版本号为’Junit-4.10-SNAPSHOT’，那么打出的包就是一个快照版本。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>秒杀系统学习笔记</title>
    <link href="/2019/12/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/12/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h2><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p><a href="https://spring.io/projects/spring-boot/">Spring Boot 官网</a></p><p><a href="https://spring.io/guides/gs/rest-service/">Spring Boot 构建一个 RESTFUL 风格的 Web 服务</a></p><p>互不 通信 的 分布式 架构 方式。 缓存 与 应用 分离 部署， 缓存 系统 部署 在 一组 专门 的 服务器 上， 应用 程序 通过 一致性 Hash 等 路 由 算法 选择 缓存 服务器 远程 访问 缓存 数据， 缓存 服务器 之间 不 通信， 缓存 集群 的 规模 可以 很容易 地 实现 扩容， 具有 良好 的 可 伸缩性。</p><p>李智慧. 大型网站技术架构:核心原理与案例分析 (p. 49). 电子工业出版社. Kindle 版本. </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于计算机网络的知识点复习...</title>
    <link href="/2019/12/14/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <url>/2019/12/14/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>既然已经决定要做开发了，就把之间放下的东西捡起来好好看看吧😝</p><h2 id="ISO-OSI-参考模型和-TCP-IP-模型"><a href="#ISO-OSI-参考模型和-TCP-IP-模型" class="headerlink" title="ISO/OSI 参考模型和 TCP/IP 模型"></a>ISO/OSI 参考模型和 TCP/IP 模型</h2><p>国际标准化组织 (ISO)提出了网络体系结构模型，称为<strong>开放互连参考模型</strong>（OSI/RM），简称为 <strong>OSI 参考模型</strong>。</p><p>共有七层</p><h2 id="数据交换的方式"><a href="#数据交换的方式" class="headerlink" title="数据交换的方式"></a>数据交换的方式</h2><ol><li><p>电路交换</p><p>在源节点和目的节点之间建立一条专用（双方独占）的通路用于传送数据，通常分为三个阶段：建立连接，传输数据和断开连接。最典型的电路交换网就是传统电话网络。</p><p>主要特点是整个报文的比特流连续的从源点到达终点，好像在一个管道中传输。优点是数据直接传送、延迟小。缺点是线路利用率低、不能充分利用线路容量。</p></li><li><p>报文交换</p><p>将用户数据附加上源地址、目的地址、校验码等辅助信息，封装成报文。整个报文传送到相邻节点，全部存储袭来后，再转发给下一个节点，重复上述过程直到到达目的节点。</p><p>报文交换也称为存储-转发。主要特点是整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p><p>优点是可以较为充分线路容量；可以实现不同链路之间不同数据率的转换；可以实现格式转换；可以实现一对多、多对一的访间；可以实现差错控制。其缺点是增加了资源开销（如辅助信息导致处理时间和存储资源的开销）：增加缓冲延迟；额外的控制机制来保证多个报文的顺序不会乱序；缓冲区难以管理，因为报文的大小不确定，接收方在接收到报文之前不能预知报文的大小。</p></li><li><p>分组交换<br>分组交换网络，也称为包交换网络。其原理是将用户数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输。</p><p>除了具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均延迟更小，网络中占用的平均缓冲区更少；更易于标准化；更适合应用。</p></li></ol><p>现在的主流网络基本上都可以看成是<strong>分组交换</strong>网络。</p><h2 id="端到端的通信和点到点的通信的区别？"><a href="#端到端的通信和点到点的通信的区别？" class="headerlink" title="端到端的通信和点到点的通信的区别？"></a>端到端的通信和点到点的通信的区别？</h2><p> 三点不同：</p><ul><li>实体不同</li><li>发生的层不同</li><li>点到点不支持可靠传输，而端到端支持</li></ul><p>从本质上说，由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，而传输层为网络中的主机提供端到端的通信。</p><p>直接相连的结点之间的通信叫点到点通信。它只提件一合却票到另一台机器之间的通信，不会涉及程序或进程的概念。同时点到点通信并不能保证数据传输的可靠性，也不能说明源主机与目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。</p><p>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到点通信更高一级的通信方式，以完成应用程序（进程）之间的通信。“端”是指用户程序的端口，端口号标识了应用层中不同的进程。</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><h3 id="单工通信"><a href="#单工通信" class="headerlink" title="单工通信"></a>单工通信</h3><p>只能有一个方向的通信，没有反方向的交互，只需要一个信道。</p><h3 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h3><p>通信的双方都可以发送或者接受消息，但是任何一方不能同时发送和接收消息，需要两个信道。</p><h3 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h3><p>通信的双方都可以同时发送和接收消息，需要两个信道。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>计算网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019 年年底，关于面试的一些总结</title>
    <link href="/2019/12/14/2019%20%E5%B9%B4%E5%B9%B4%E5%BA%95%EF%BC%8C%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    <url>/2019/12/14/2019%20%E5%B9%B4%E5%B9%B4%E5%BA%95%EF%BC%8C%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<p>这一周面试了腾讯和百度的「数据开发」岗，对这个岗位有了更加清楚的认识和定位，数据开发岗就是为大数据的全生命周期提供服务，包括数据产生，传输，建模，统计</p><p>分析，实验评估，可视化的全流程。</p><p>负责的工作主要包括：</p><ul><li><p>前期的工作主要就是 ETL，将数据从来源端经过抽取（extract）、转换（transform）、加载（load）到数据库中的过程。</p><p>这部分可能需要掌握一些数据库的基本理论、SQL 以及大数据组件的使用和调优，比如 Hadoop，Hive和HBase，很少会涉及组件的大规模二次开发</p></li><li><p>中期工作就是数据分析，通过上一个过程获得的数据，开始建模分析，以达到一定的目的。</p><p>这部分通常是使用机器学习算法（但不限于机器学习算法）来达到建模分析的目的。</p><p>这部分工作和数学建模中的「数据题」的解答过程很像。</p></li><li><p>结果展示</p><p>一般就是指 BI 报表、可视化或者可行性分析。</p></li></ul><p>因为不同部门对于数据开发的定义和负责的工作不太一样，我根据我的认识将数据开发岗和其他的岗位进行一下对比</p><p><strong>算法工程师</strong></p><blockquote><p>数据开发或者说数据分析岗位和算法岗有相似的地方，也有不同的地方</p><p>两者都需要使用机器学习算法对数据进行建模分析，但是算法工程师中算法的使用会直接上线，作用到生产环境中。而数据分析的算法是在离线环境下进行的，是为了分析业务结果而进行。</p><p>举一个不恰当的例子，拿某新闻 APP 举例，新闻组的推荐算法是直接作用到业务上的，会决定你推荐的结果，而数据分析负责的工作是当新闻 APP 的用户日使用量出现下降时，我们使用算法来分析为什么会出现用户日使用量的下降。数据分析师的算法并不会直接作用到业务，而是挖掘数据中的信息，为了理解业务而进行的。</p><p>并且技术栈也会有明显不同，数据开发对于大数据组件的使用和调优、以及SQL的使用要求更高，而算法工程师则是算法的设计、实现、调参有更高的要求，主要是对于编程能力和数学功底的要求。</p></blockquote><p><strong>数据仓库工程师</strong></p><blockquote><p>数据仓库岗与数据开发岗的关系更像是数据开发的进阶版。数据仓库开发人员还要参与数据仓库 ETL 流程设计、开发和优化，解决 ETL 过程相关技术问题</p><p>这就在数据开发岗的要求之上，要求数据仓库开发人员熟悉数据仓库各类模型建模理论，了解数据仓库数据分层架构，多维数据模型设计，理论性更强一些。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/2019/12/12/ConcurrentHashMap/"/>
    <url>/2019/12/12/ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    <span class="hljs-keyword">volatile</span> V value;    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;&#125;</code></pre><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap引入了一个分段的概念（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）</p><p>Segment 继承自 ReentrantLock。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2249069246763182397L</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SCAN_RETRIES =        Runtime.getRuntime().availableProcessors() &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">64</span> : <span class="hljs-number">1</span>;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> threshold;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;</code></pre><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="hljs-number">16</span>;</code></pre><p>从上面的结构我们可以了解到，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。</p><p>第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</p><p><strong>坏处</strong></p><p>这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长</p><p><strong>好处</strong></p><p>写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上）。</p><p>所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</p><h3 id="Size方法"><a href="#Size方法" class="headerlink" title="Size方法"></a>Size方法</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The number of elements. Accessed only either within locks</span><span class="hljs-comment"> * or among other volatile reads that maintain visibility.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;</code></pre><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Number of unsynchronized retries in size and containsValue</span><span class="hljs-comment"> * methods before resorting to locking. This is used to avoid</span><span class="hljs-comment"> * unbounded retries if tables undergo continuous modification</span><span class="hljs-comment"> * which would make it impossible to obtain an accurate result.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RETRIES_BEFORE_LOCK = <span class="hljs-number">2</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Try a few times to get accurate count. On failure due to</span>    <span class="hljs-comment">// continuous async changes in table, resort to locking.</span>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="hljs-keyword">this</span>.segments;    <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">boolean</span> overflow; <span class="hljs-comment">// true if size overflows 32 bits</span>    <span class="hljs-keyword">long</span> sum;         <span class="hljs-comment">// sum of modCounts</span>    <span class="hljs-keyword">long</span> last = <span class="hljs-number">0L</span>;   <span class="hljs-comment">// previous sum</span>    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>; <span class="hljs-comment">// first iteration isn&#x27;t retry</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 超过尝试次数，则对每个 Segment 加锁</span>            <span class="hljs-keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)                    ensureSegment(j).lock(); <span class="hljs-comment">// force creation</span>            &#125;            sum = <span class="hljs-number">0L</span>;            size = <span class="hljs-number">0</span>;            overflow = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j) &#123;                Segment&lt;K,V&gt; seg = segmentAt(segments, j);                <span class="hljs-keyword">if</span> (seg != <span class="hljs-keyword">null</span>) &#123;                    sum += seg.modCount;                    <span class="hljs-keyword">int</span> c = seg.count;                    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || (size += c) &lt; <span class="hljs-number">0</span>)                        overflow = <span class="hljs-keyword">true</span>;                &#125;            &#125;            <span class="hljs-comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span>            <span class="hljs-keyword">if</span> (sum == last)                <span class="hljs-keyword">break</span>;            last = sum;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)                segmentAt(segments, j).unlock();        &#125;    &#125;    <span class="hljs-keyword">return</span> overflow ? Integer.MAX_VALUE : size;&#125;</code></pre><h2 id="二、JDK-8"><a href="#二、JDK-8" class="headerlink" title="二、JDK 8"></a>二、JDK 8</h2><p>JDK8 中彻底放弃了 Segment 转而采用的是 Node ，其设计思想也不再是 JDK7 中的分段锁思想。</p><p>在 JDK8 中 ConcurrentHashMap 利用 CAS + Synchronized 来确保线程安全，它的底层数据结构依然是数组+链表+红黑树。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><pre><code class="hljs java"><span class="hljs-comment">// ConcurrentHashMap核心数组</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">16</span>;<span class="hljs-comment">// 扩容时才会用的一个临时数组</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 表初始化和大小调整控件</span><span class="hljs-comment"> * -1 表示正在初始化</span><span class="hljs-comment"> * -n 表示有n-1的线程正在扩容.  </span><span class="hljs-comment"> * 当 table 为空时, 用来存储要初始化的表的值的大小</span><span class="hljs-comment"> * 当 table 已经初始化以后，表示用来调整表大小的值</span><span class="hljs-comment"> * 总之，sizeCtl 为正和为负表示截然不同的概念</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;<span class="hljs-comment">// resize的时候下一个需要处理的元素下标为index=transferIndex-1</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> transferIndex;<span class="hljs-comment">// 通过CAS无锁更新，ConcurrentHashMap元素总数，但不是准确值</span><span class="hljs-comment">// 因为多个线程同时更新会导致部分线程更新失败，失败时会将元素数目变化存储在counterCells中</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> baseCount;<span class="hljs-comment">// resize或者创建CounterCells时的一个标志位</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<span class="hljs-comment">// 用于存储元素变动</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> CounterCell[] counterCells;</code></pre><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="Unsafe-compareAndSwapXXX-方法"><a href="#Unsafe-compareAndSwapXXX-方法" class="headerlink" title="Unsafe.compareAndSwapXXX 方法"></a>Unsafe.compareAndSwapXXX 方法</h4><p><code>Unsafe.compareAndSwapXXX()</code> 方法是 sun.misc.Unsafe 类中的方法，因为在 ConcurrentHashMap 中大量使用了这些方法。其声明如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapXXX</span><span class="hljs-params">(type1 object, type2 offset, type4 expect, type5 update)</span></span>;</code></pre><p>方法的伪逻辑如下：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (object[offset].value equal expect) &#123;    object[offset].value = update;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125; <span class="hljs-keyword">else</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</code></pre><p>CAS方法都是native方法，可以保证原子性，并且效率比synchronized高。 </p><p>关于CAS方法的原理，建议参考一下两篇博客，强烈推荐</p><p><a href="http://www.dataguru.cn/java-865024-1-1.html">http://www.dataguru.cn/java-865024-1-1.html</a></p><p><a href="https://www.cnblogs.com/Mainz/p/3546347.html">https://www.cnblogs.com/Mainz/p/3546347.html</a></p><h4 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h4><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_BITS = <span class="hljs-number">0x7fffffff</span>; <span class="hljs-comment">// usable bits of normal node hash</span><span class="hljs-keyword">int</span> hash = spread(key.hashCode());<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">spread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;    <span class="hljs-keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)) &amp; HASH_BITS;&#125;</code></pre><p>h ^ (h &gt;&gt;&gt; 16) 在计算 hash 的时候 key.hashCode() 的高位也参与运算，这部分跟 HashMap 计算方法一致，不同的是 h ^ (h &gt;&gt;&gt; 16) 计算结果 &amp; 上 0x7fffffff ，从而保证结果一定为正整数。获得 hash 之后，通过hash &amp; (n -1)计算下标。</p><p>为什么要多添加一个与操作呢，看后面的注释</p><blockquote><p>usable bits of normal node hash</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MOVED     = -<span class="hljs-number">1</span>; <span class="hljs-comment">// hash for forwarding nodes</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEBIN   = -<span class="hljs-number">2</span>; <span class="hljs-comment">// hash for roots of trees</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RESERVED  = -<span class="hljs-number">3</span>; <span class="hljs-comment">// hash for transient reservations</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_BITS = <span class="hljs-number">0x7fffffff</span>; <span class="hljs-comment">// usable bits of normal node hash</span></code></pre><p>ConcurrentHashMap 中的元素节点总结一下有这么几种可能：</p><ul><li><p>null </p></li><li><p>Node<K, v> 普通节点，可以组成单向链表，hash &gt; 0</K,></p></li><li><p>TreeBin<K,V> 红黑树节点，TreeBin 是对 TreeNode 的封装，其 hash 为 TREEBIN = -2。</K,V></p><p>HashMap 和 ConcurrentHashMap 的 TreeNode 实现并不相同。</p><p>在 HashMap 中 TreeNode 封装了红黑树所有的操作方法，而 ConcurrentHashMap 中红黑树操作的方法都封装在 TreeBin 中，TreeBin 相当于一个红黑树容器，容器中的红黑树节点为 TreeNode 。</p><p>HashMap 可以直接在 tab[i] 存入 TreeNode ，而 ConCurrentHashMap 只能在 tab[i] 存入 TreeBin 。</p></li><li><p>ForwardingNode<K,V> key 和 value 都为 null 的一个特殊节点，用于 resize 操作填充已经完成迁移操作的节点。FrowardingNode 的hash在初始化的时候被置成MOVED = -1</K,V></p><p>在 resize 过程中当发现 tab[i] 上是 ForwardingNode 的时候（通过hash判断）就可知 tab[i] 已经迁移完了，直接跳过该节点去处理其它节点。</p><p>ConcurrentHashMap禁止 node 的 key 或 value 为 null 或许跟该节点的存在也是有一定关系的。</p></li><li><p>ReservationNode<K,V>只在 compute 和 computeIfAbsent 中使用，其hash为RESERVED = -3</K,V></p></li></ul><p>从上面的总结可以看出普通节点hash为正整数是有意义的，hash &gt; 0是判断该节点是否为链表节点（普通节点）的一个重要依据。</p><h4 id="get-set-update-tab-i-方法"><a href="#get-set-update-tab-i-方法" class="headerlink" title="get/set/update tab[i] 方法"></a>get/set/update tab[i] 方法</h4><pre><code class="hljs java"><span class="hljs-comment">// 获取tab[i]节点</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);&#125;<span class="hljs-comment">// compare and swap tab[i]，期望值是c，tab[i].value == c ? tab[i] = v : return false</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;<span class="hljs-comment">// 设置tab[i] = v</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;    U.putObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);&#125;</code></pre><h4 id="size-方法"><a href="#size-方法" class="headerlink" title="size() 方法"></a>size() 方法</h4><p>ConcurrentHashMap中baseCount用于保存tab中元素总数，但是并不准确，因为多线程同时增删改，会导致baseCount修改失败，此时会将元素变动存储于counterCells数组内。</p><p>当需要统计当前的size的时候，除了要统计baseCount之外，还需要统计counterCells中的元素变化。</p><p>值得一提的是即使如此，统计出来的依旧不是当前tab中元素的准确值，在多线程环境下统计前后并不能stop the world暂停线程操作，因此无法保证准确性。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> n = sumCount();    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> : (n &gt; (<span class="hljs-keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="hljs-keyword">int</span>)n);&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sumCount</span><span class="hljs-params">()</span> </span>&#123;    CounterCell[] as = counterCells;     CounterCell a;    <span class="hljs-keyword">long</span> sum = baseCount;    <span class="hljs-comment">// 除了baseCount以外，部分元素变化存储在counterCells数组中</span>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 遍历数组累加获得结果</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)                sum += a.value;        &#125;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre><h4 id="put-putIfAbsent方法"><a href="#put-putIfAbsent方法" class="headerlink" title="put/putIfAbsent方法"></a>put/putIfAbsent方法</h4><p>现在对put(putVal)方法做一个总结:</p><ol><li>如果待插入的键值对中 key 或 value 为 null，抛出异常，结束。否则执行2</li><li>如果 table 为 null，则进行初始化操作 initTable()，否则执行3</li><li>如果 table[i] 为空，则用 CAS 在 table[i] 头结点直接插入，如果 CAS 执行成功，退出插入操作，执行步骤 7；如果 CAS 失败,则说明有其他节点已经插入，执行4</li><li>此时判断，hash 值是否为 MOVED(-1)，如果是则说明其他有其他线程在执行扩容操作，帮助他们一起扩容，来提高性能。如果没有在扩容,那么执行5</li><li>判断 hash 的值，如果&gt;=0，则在链表合适的位置插入，否则，查看 table[i] 是否是红黑树结构，如果是，则在红黑树适当位置插入。到此时，值对已经顺利插入，接下来执行6</li><li>如果 table[i] 节点数binCount不为0，判断它此时的状态,是否需要转变为红黑树</li><li>执行 addcount(1L, binCount)</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-comment">// 核心是调用putVal方法</span>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-comment">// 如果key存在就不更新value</span>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    <span class="hljs-comment">// key或value 为null都是不允许的，因为Forwarding Node就是key和value都为null，是用作标志位的。</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// 根据key计算hash值，有了hash就可以计算下标了</span>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 可能需要初始化或扩容，因此一次未必能完成插入操作，所以添加上for循环</span>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f;  <span class="hljs-comment">//用来存储要插入的键值对</span>        <span class="hljs-comment">// i 表示要插入的下标, fh 表示要要插入的键值对的 hash 值</span>        <span class="hljs-keyword">int</span> n, i, fh;         <span class="hljs-comment">// 表还没有初始化，先初始化，lazily initialized</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            tab = initTable();        <span class="hljs-comment">// 根据hash计算应该插入的index</span>        <span class="hljs-comment">// table[i]为空,用CAS在table[i]头结点直接插入,退出插入操作;</span>        <span class="hljs-comment">// 如果CAS失败,则有其他节点已经插入,继续下一步</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-comment">// MOVED for forwarding nodes</span>        <span class="hljs-comment">// 说明f为ForwardingNode，只有扩容的时候才会有ForwardingNode出现在tab中，因此可以断定该tab正在进行扩容</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)              <span class="hljs-comment">// 协助扩容            </span>            tab = helpTransfer(tab, f);           <span class="hljs-keyword">else</span> &#123;            V oldVal = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">// 对链表头结点上锁</span>            <span class="hljs-keyword">synchronized</span> (f)             &#123;                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f)                 &#123;                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 是链表节点</span>                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount)                         &#123;                            K ek;                            <span class="hljs-comment">// 遍历链表查找是否包含该元素</span>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))                             &#123;                                oldVal = e.val;  <span class="hljs-comment">// 保存旧的值用于当做返回值</span>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                    e.val = value;  <span class="hljs-comment">// 替换旧的值为新值</span>                                <span class="hljs-keyword">break</span>;                            &#125;                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>)                             &#123;                                <span class="hljs-comment">// 遍历链表，如果一直没找到，则新建一个Node放到链表结尾</span>                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) <span class="hljs-comment">// 是红黑树节点</span>                    &#123;                         Node&lt;K,V&gt; p;                        binCount = <span class="hljs-number">2</span>;                        <span class="hljs-comment">// 去红黑树查找该元素，如果没找到就添加，找到了就返回该节点</span>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="hljs-keyword">null</span>) &#123;                            <span class="hljs-comment">// 保存旧的value用于返回</span>                            oldVal = p.val;                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                p.val = value; <span class="hljs-comment">// 替换旧的值</span>                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>)             &#123;                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                    <span class="hljs-comment">// 链表长度超过阈值（默认为8），则需要将链表转为一棵红黑树</span>                    treeifyBin(tab, i);                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)                    <span class="hljs-comment">// 如果只是替换，并未带来节点的增加则直接返回旧的value即可</span>                    <span class="hljs-keyword">return</span> oldVal;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 元素总数加1，并且判断是否需要扩容</span>    addCount(<span class="hljs-number">1L</span>, binCount);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h4 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h4><pre><code class="hljs java"><span class="hljs-comment">// check&lt;0不检查resize, check&lt;=1只在没有线程竞争的情况下检查resize</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> check)</span> </span>&#123;    CounterCell[] as;     <span class="hljs-keyword">long</span> b, s;    <span class="hljs-comment">// counterCells数组不为null       </span>    <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-keyword">null</span> ||        <span class="hljs-comment">// CAS更新BASECOUNT失败（有其它线程更新了BASECOUNT，baseCount已经不是最新值）</span>        !U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, b = baseCount, s = b + x))     &#123;        CounterCell a;         <span class="hljs-keyword">long</span> v;         <span class="hljs-keyword">int</span> m;        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// counterCells为null</span>        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||            <span class="hljs-comment">// counterCells对应位置为null，这里不是很懂，有没有大神解答下？</span>            <span class="hljs-comment">// ThreadLocalRandom.getProbe() 获得线程探测值，什么用途？</span>            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||            <span class="hljs-comment">// 更新CELLVALUE失败</span>            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;            <span class="hljs-comment">// 初始化counterCells</span>            fullAddCount(x, uncontended);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// counterCells != null 或者 BASECOUNT CAS更新失败都是因为有线程竞争，因此不检查resize</span>        <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 统计下ConcurrentHashMap元素总数    </span>        s = sumCount();    &#125;    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-keyword">int</span> n, sc;        <span class="hljs-comment">// 元素总数大于sizeCtl</span>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;            <span class="hljs-comment">// 获取一个resize标志位   </span>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);            <span class="hljs-comment">// sizeCtl &lt; 0 表示table正在初始化或者resize</span>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> || transferIndex &lt;= <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))                    transfer(tab, nt);            &#125;            <span class="hljs-comment">// 当前线程是第一个发起扩容操作</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))                transfer(tab, <span class="hljs-keyword">null</span>);            s = sumCount();        &#125;    &#125;&#125;</code></pre><h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。</span><span class="hljs-comment"> * 所以执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，</span><span class="hljs-comment"> * 有且只有一个线程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;    Node&lt;K,V&gt;[] tab;     <span class="hljs-keyword">int</span> sc;    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//sizeCtl 为负值时，表示线程在初始化或者扩容</span>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">int</span> n = (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];                    table = tab = nt;                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                sizeCtl = sc;            &#125;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> tab;&#125;</code></pre><h4 id="resize相关方法：resizeStamp、helpTransfer、transfer"><a href="#resize相关方法：resizeStamp、helpTransfer、transfer" class="headerlink" title="resize相关方法：resizeStamp、helpTransfer、transfer"></a>resize相关方法：resizeStamp、helpTransfer、transfer</h4><pre><code class="hljs java"><span class="hljs-comment">// 返回一个标志位，该标志位经过RESIZE_STAMP_SHIFT左移必定为负数</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">resizeStamp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// Integer.numberOfLeadingZeros返回n对应32位二进制数左侧0的个数，如9（1001）返回28  </span>    <span class="hljs-comment">// 1 &lt;&lt; (RESIZE_STAMP_BITS - 1) = 2^15，其中RESIZE_STAMP_BITS固定为16</span>    <span class="hljs-keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="hljs-number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="hljs-number">1</span>));&#125;</code></pre><p> table是一个链表数组，默认为空，初始化操作延迟到了第一次执行put，默认大小DEFAULT_CAPACITY=16 ,执行扩容后，总为2的n次幂</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    <span class="hljs-keyword">volatile</span> V val;    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;    Node(<span class="hljs-keyword">int</span> hash, K key, V val) &#123;        <span class="hljs-keyword">this</span>.hash = hash;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.val = val;    &#125;    Node(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;        <span class="hljs-keyword">this</span>(hash, key, val);        <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>     </span>&#123; <span class="hljs-keyword">return</span> key; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>   </span>&#123; <span class="hljs-keyword">return</span> val; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Helpers.mapEntryToString(key, val);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        Object k, v, u; Map.Entry&lt;?,?&gt; e;        <span class="hljs-keyword">return</span> ((o <span class="hljs-keyword">instanceof</span> Map.Entry) &amp;&amp;                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="hljs-keyword">null</span> &amp;&amp;                (v = e.getValue()) != <span class="hljs-keyword">null</span> &amp;&amp;                (k == key || k.equals(key)) &amp;&amp;                (v == (u = val) || v.equals(u)));    &#125;</code></pre><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>上面提到，初始化操作发生在第一次put操作，那么多个线程执行put时，如何保证只执行一次初始化呢?</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">//计算hash值</span>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开始执行插入操作</span>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f;         <span class="hljs-keyword">int</span> n, i, fh;       <span class="hljs-comment">//如果table为空,执行初始化操作</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            tab = initTable();        <span class="hljs-comment">//table[i]为空,用CAS在table[i]头结点直接插入,退出插入操作;如果CAS失败,则有其他节点已经插入,继续下一步</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-comment">//如果table[i]不为空,且table[i]的hash值为-1,则有其他线程在执行扩容操作,帮助他们一起扩容,提高性能</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);       <span class="hljs-comment">//如果没有在扩容</span>        <span class="hljs-keyword">else</span> &#123;            V oldVal = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">synchronized</span> (f) &#123;                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    <span class="hljs-comment">//fh(table[i])的hash&gt;=0,则此时table[i]为链表结构,找到合适位置插入</span>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                    e.val = value;                                <span class="hljs-keyword">break</span>;                            &#125;                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,                                                          value, <span class="hljs-keyword">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">//fh(table[i])的hash&lt;0,table[i]为红黑树结构,这个过程采用同步内置锁实现并发</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = <span class="hljs-number">2</span>;                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != <span class="hljs-keyword">null</span>) &#123;                            oldVal = p.val;                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;<span class="hljs-comment">//到此时,已将键值对插入到了合适的位置,检查链表长度是否超过阈值,若是,则转变为红黑树结构</span>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> oldVal;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//count+1,如有必要,则扩容</span>    addCount(<span class="hljs-number">1L</span>, binCount);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><pre><code class="hljs java"></code></pre><p>Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。</p><p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p><p>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。<br>2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。<br>3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。<br>4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。<br>5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2019/12/12/HashMap/"/>
    <url>/2019/12/12/HashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的部分内容参考<a href="https://link.zhihu.com/?target=https%3A//cyc2018.github.io/CS-Notes/%23/notes/Java%20%E5%AE%B9%E5%99%A8%3Fid%3Dhashmap">cyc2018.github.io/CS-Notes/HashMap</a>，结合本人理解和JDK1.8进行了部分的更改，如果有理解或者编辑错误，望指出。</p><h2 id="一、存储结构"><a href="#一、存储结构" class="headerlink" title="一、存储结构"></a>一、存储结构</h2><p>HashMap内部维护了一个Node类型的数组</p><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;</code></pre><p>Node 类是 HashMap 的一个静态内部类，主要是由4个字段，从 next 字段我们可以看出 Node 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决地址冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Node。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    V value;    Node&lt;K,V&gt; next;    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;        <span class="hljs-keyword">this</span>.hash = hash;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.value = value;        <span class="hljs-keyword">this</span>.next = next;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;        V oldValue = value;        value = newValue;        <span class="hljs-keyword">return</span> oldValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;                    Objects.equals(value, e.getValue()))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>使用拉链法进行查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li></ul><h2 id="二、如何确定桶的下标"><a href="#二、如何确定桶的下标" class="headerlink" title="二、如何确定桶的下标"></a>二、如何确定桶的下标</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;    <span class="hljs-keyword">int</span> h;    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;<span class="hljs-comment">//n 是当前的容量</span>p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]</code></pre><h3 id="为什么要这样计算哈希值？"><a href="#为什么要这样计算哈希值？" class="headerlink" title="为什么要这样计算哈希值？"></a>为什么要这样计算哈希值？</h3><p><a href="https://zhuanlan.zhihu.com/p/76784693">https://zhuanlan.zhihu.com/p/76784693</a></p><h3 id="为什么链表数组的长度为偶数"><a href="#为什么链表数组的长度为偶数" class="headerlink" title="为什么链表数组的长度为偶数"></a>为什么链表数组的长度为偶数</h3><p>通过hash值计算桶的下标的时候，我们本应该是</p><pre><code class="hljs java">p = tab[i = hash % n]</code></pre><p>但是Java中的实现却是</p><pre><code class="hljs java">p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]</code></pre><p>令 x 为 2 的 4 次方，它具有以下性质：</p><pre><code class="hljs text">x   : 00010000x-1 : 00001111</code></pre><p>令一个数 y 与 x-1 做「与」运算</p><pre><code class="hljs text">y       : 10110010x-1     : 00001111y &amp; (x-1) : 00000010</code></pre><p>这个性质和 y 对 x 取模效果是一样的：</p><pre><code class="hljs text">y   : 10110010x   : 00010000y%x : 00000010</code></pre><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p><h2 id="三、put操作"><a href="#三、put操作" class="headerlink" title="三、put操作"></a>三、put操作</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    Node&lt;K,V&gt;[] tab;     Node&lt;K,V&gt; p;     <span class="hljs-keyword">int</span> n, i;    <span class="hljs-comment">//1.先判断链表数组是否为空</span>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;    <span class="hljs-comment">//2.确定桶下标</span>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//3.使用拉链法解决地址冲突</span>        Node&lt;K,V&gt; e;         K k;        <span class="hljs-comment">//3.1判断是否是相同的key，需要进行覆盖</span>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            e = p;        <span class="hljs-comment">//3.2.1 如果当前桶的链表已经被组织成红黑树了，调用红黑树的putTreeVal方法</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//3.2.2 遍历链表插入节点</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">break</span>;                p = e;            &#125;        &#125;        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>            V oldValue = e.value;            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                e.value = value;            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    <span class="hljs-comment">//4.判断是否扩容</span>    ++modCount;    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><h2 id="四、扩容后重新计算下标"><a href="#四、扩容后重新计算下标" class="headerlink" title="四、扩容后重新计算下标"></a>四、扩容后重新计算下标</h2><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><pre><code class="hljs html">capacity     : 00010000new capacity : 00100000</code></pre><p>对于一个 Key，</p><ul><li>它的哈希值如果在第 5 位上为 0，那么扩容后的下标和之前一样；</li><li>如果为 1，那么扩容后的下标为原来的下标 +16。</li></ul><p>我们可以通过下面代码，判断是否需要扩容</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>)    <span class="hljs-comment">//说明e.hash对应oldCap二进制为1的那一位为0，桶的下标不变</span><span class="hljs-keyword">else</span>    <span class="hljs-comment">//下标变为oldIndex + oldCap</span></code></pre><p>举一个具体的例子</p><pre><code class="hljs java">第一个键值对的hash值的二进制为 <span class="hljs-number">10001</span>(<span class="hljs-number">17</span>) 对应的下标为 <span class="hljs-number">17</span> % <span class="hljs-number">16</span> =<span class="hljs-number">1</span>第二个键值对的hash值的二进制为 <span class="hljs-number">00001</span>(<span class="hljs-number">1</span>) 对应的下标为 <span class="hljs-number">1</span> % <span class="hljs-number">16</span> =<span class="hljs-number">1</span></code></pre><p>原数组长度 capacity 为 16 时，这两个键值对都应该放在同一个桶里面，但是扩容后</p><pre><code class="hljs java">第一个键值对的hash值的二进制为 <span class="hljs-number">10001</span>(<span class="hljs-number">17</span>) 对应的下标为 <span class="hljs-number">17</span> % <span class="hljs-number">32</span> = <span class="hljs-number">17</span>第二个键值对的hash值的二进制为 <span class="hljs-number">00001</span>(<span class="hljs-number">1</span>) 对应的下标为 <span class="hljs-number">1</span> % <span class="hljs-number">32</span> = <span class="hljs-number">1</span></code></pre><h2 id="五、扩容"><a href="#五、扩容" class="headerlink" title="五、扩容"></a>五、扩容</h2><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p><p>capacity</p><blockquote><p>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</p></blockquote><p>size</p><blockquote><p>键值对数量</p></blockquote><p>threshold</p><blockquote><p>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</p></blockquote><p>loadFactor</p><blockquote><p>装载因子，table 能够使用的比例，threshold = (int)(newCapacity * loadFactor)。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<span class="hljs-keyword">transient</span> Entry[] table;<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<span class="hljs-keyword">int</span> threshold;<span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;</code></pre><p>resize 方法主要用来初始化链表数组或者让链表数组的长度变为原来的2倍.</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-keyword">int</span> oldThr = threshold;    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;    <span class="hljs-comment">//1.如果容量不为0</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>)     &#123;   <span class="hljs-comment">//1.1判断容量是否已经到了最大值</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">//1.2 如果没有到达最大容量，就将容量变为原来的2倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>;     &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)  <span class="hljs-comment">//如果是指定初始容量的话，使用阈值去初始化-&gt;这种是针对有参数的构造方法</span>        newCap = oldThr;    <span class="hljs-keyword">else</span> &#123;           <span class="hljs-comment">//2.如果是初始化，使用DEFAULT_INITIAL_CAPACITY来初始化容量</span>        newCap = DEFAULT_INITIAL_CAPACITY; <span class="hljs-comment">//16</span>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//这点没太看懂</span>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?(<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);    &#125;    threshold = newThr;    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>    <span class="hljs-comment">//3、创建一个新的链表数组，开始一点一点的搬运</span>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];    table = newTab;    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;                oldTab[j] = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;                        loTail.next = <span class="hljs-keyword">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;                        hiTail.next = <span class="hljs-keyword">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newTab;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志分析系统</title>
    <link href="/2019/12/08/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/12/08/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h2 id="项目所用的组件版本"><a href="#项目所用的组件版本" class="headerlink" title="项目所用的组件版本"></a>项目所用的组件版本</h2><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Zookeeper 两个最重要的系统模型：ZNode 和 Watcher</p><h3 id="ZNode"><a href="#ZNode" class="headerlink" title="ZNode"></a>ZNode</h3><p>在 Zookeeper 中节点有三种类型：</p><ul><li>持久节点（persistent）</li><li>临时节点（ephemeral）</li><li>顺序节点</li></ul><p>在节点创建过程中，通过组合使用，可是生成 4 种组合型节点</p><p><strong>持久节点</strong></p><p>持久节点是指数据节点创建后，就会一直存在 Zookeeper 服务器上，直到有删除操作删除这个节点。</p><p><strong>临时节点</strong></p><p>与持久节点不同，临时节点的生命周期与客户端的会话联系在一起。也就说，如果客户端会话失效，那么这个客户端创建的临时节点就会被删除。</p><h3 id="Watcher-数据变更的通知"><a href="#Watcher-数据变更的通知" class="headerlink" title="Watcher - 数据变更的通知"></a>Watcher - 数据变更的通知</h3><p>Zookeeper 通过 Watcher 机制提供了一种分布式数据订阅/发布功能。Zookeeper 允许客户端在一个节点上注册一个 Watcher 事件监听，一旦一些事务对这个节点做一些操作，就会触发了这个 Watcher，客户端就会收到一个事件通知。</p><p>理解了 ZNode 和 Watcher 基本上就能大致了解 Zookeeper 的运行机制。</p><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><h3 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a>预分区</h3><h3 id="RowKey-设计"><a href="#RowKey-设计" class="headerlink" title="RowKey 设计"></a>RowKey 设计</h3><p>在 HBase 中一条记录的唯一标识就是 rowkey ，那么这条数据存储于哪个 region，取决于 rowkey 处于哪个一个预分区的区间内。</p><p><strong>设计 rowkey 的主要目的 ，就是让数据均匀的分布于所有的 region 中，在一定程度上防止数据倾斜。</strong></p><h4 id="rowkey-长度原则"><a href="#rowkey-长度原则" class="headerlink" title="rowkey 长度原则"></a>rowkey 长度原则</h4><p>Rowkey 是一个二进制码流，Rowkey 的长度被很多开发者建议说设计在 10~100 个字节，不过建议是越短越好，不要超过 16 个字节，存为byte[]字节数组，<strong>一般设计成定长的</strong>。</p><p>原因如下：</p><ol><li>数据的持久化文件 HFile 中是按照 KeyValue 存储的，如果 Rowkey 过长比如 100 个字 节，1000 万列数据光 Rowkey 就要占用 100*1000 万=10 亿个字节，将近 1G 数据，这会极大 影响 HFile 的存储效率；</li><li>MemStore 将缓存部分数据到内存，如果 Rowkey 字段过长内存的有效利用率会降低， 系统将无法缓存更多的数据，这会降低检索效率。因此 Rowkey 的字节长度越短越好。</li><li>目前操作系统是都是 64 位系统，内存 8 字节对齐。控制在 16 个字节，8 字节的整数 倍利用操作系统的最佳特性。</li></ol><h4 id="rowkey-散列原则"><a href="#rowkey-散列原则" class="headerlink" title="rowkey 散列原则"></a>rowkey 散列原则</h4><p>如果 Rowkey 是按时间戳的方式递增，不要将时间放在二进制码的前面，建议将 Rowkey 的高位作为散列字段，由程序循环生成，低位放时间字段，这样将提高数据均衡分布在每个 RegionServer 实现负载均衡的几率。</p><p>如果没有散列字段，首字段直接是时间信息将产生所有 新数据都在一个 RegionServer 上堆积的热点现象，这样在做数据检索的时候负载将会集中 在个别 RegionServer，降低查询效率。</p><p>row key是按照<strong>字典序</strong>存储，因此，设计row key时，要充分利用这个排序特点，将经常一起读取的数据存储到一块，将最近可能会被访问的数据放在一块。</p><p>举个例子：如果最近写入HBase表中的数据是最可能被访问的，可以考虑将时间戳作为row key的一部分，由于是字典序排序，所以可以使用 <code>Long.MAX_VALUE - timestamp</code> 作为rowkey，这样能保证新写入的数据在读取时可以被快速命中。</p><h4 id="rowkey-唯一原则"><a href="#rowkey-唯一原则" class="headerlink" title="rowkey 唯一原则"></a>rowkey 唯一原则</h4><p>必须在设计上保证其唯一性。rowkey 是按照字典顺序排序存储的，因此，设计 rowkey 的时候，要充分利用这个排序的特点，将经常读取的数据存储到一块，将最近可能会被访问 的数据放到一块。</p><p>在日志数据中，用户 id 有 16 位左右，时间是 8 位，当前时间是 <code>System.currentTimeMillis()</code>不足16位，补 0. </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleRowKeyGenerator</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] getUUIDKey(String prefix) <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;        <span class="hljs-keyword">return</span> (prefix + UUID.randomUUID().toString()).getBytes(<span class="hljs-string">&quot;UTF8&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] getRandomKey(String prefix) <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;        <span class="hljs-keyword">return</span> (prefix + String.valueOf(<span class="hljs-keyword">new</span> Random().nextLong())).getBytes(<span class="hljs-string">&quot;UTF8&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] getTimestampKey(String prefix) <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;        <span class="hljs-keyword">return</span> (prefix + String.valueOf(System.currentTimeMillis())).getBytes(<span class="hljs-string">&quot;UTF8&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] getNanoTimestampKey(String prefix) <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;        <span class="hljs-keyword">return</span> (prefix + String.valueOf(System.nanoTime())).getBytes(<span class="hljs-string">&quot;UTF8&quot;</span>);    &#125;    <span class="hljs-comment">// 自定义 RowKey</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] getKfkRowKey(String userid,String datetime)<span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;        <span class="hljs-keyword">return</span> (userid + datetime + String.valueOf(System.currentTimeMillis())).getBytes(<span class="hljs-string">&quot;UTF8&quot;</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>大数据</tag>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用两种锁实现带有环形缓冲区的生产者消费者模型</title>
    <link href="/2019/12/08/The_producer-consumer_model_with_ring_buffers_is_implemented_using_two_types_of_locks/"/>
    <url>/2019/12/08/The_producer-consumer_model_with_ring_buffers_is_implemented_using_two_types_of_locks/</url>
    
    <content type="html"><![CDATA[<h2 id="使用synchronized关键字"><a href="#使用synchronized关键字" class="headerlink" title="使用synchronized关键字"></a>使用<code>synchronized</code>关键字</h2><p>我们使用<strong>双指针</strong>法构建了一个环形缓冲区，使用环形缓冲区有几个需要注意的地方</p><ul><li><p>其中 head 表示缓冲区的开始，tail 表示缓冲区的结束，[head,tail) 前闭后开表示缓冲区中有数据的空间。</p><ul><li>初始化 head = tail = 0 表示缓冲区为空</li><li>随着生产物品 tail 不断的增加 <code>tail = (tail + 1) % CAPACITY</code></li><li>直到 <code>(tail + 1) % CAPACITY == head</code>表示缓冲区满</li></ul></li><li><p>有一个空间会被空置，作为缓冲区满的判断标志，所以真正的容量为 CAPACITY - 1。</p></li></ul><p>其次，关于 synchronized 关键字有几个需要注意的地方</p><ul><li>synchronized 是要结合 <code>Object.wait()</code> 和 <code>Object.notify</code> 或者 <code>Object.notifyAll()</code> 使用，具体说明请看文章 <a href="https://zhuanlan.zhihu.com/p/76625784">为什么wait()和notify()需要搭配synchonized关键字使用?</a></li><li>因为 synchronized 只有一个阻塞队列，当多生产者多消费者时，唤醒时需要使用 <code>Object.notifyAll()</code></li><li>还有就是可能会出现的中断异常 InterruptedException 。</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[CAPACITY];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//生产者</span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">synchronized</span> (buffer) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                        <span class="hljs-keyword">while</span> ((tail + <span class="hljs-number">1</span>) % CAPACITY == head) &#123;                            <span class="hljs-keyword">try</span> &#123;                                buffer.wait();                            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                                e.printStackTrace();                            &#125;                        &#125;                        buffer[tail] = i;                        tail = (tail + <span class="hljs-number">1</span>) % CAPACITY;                        System.out.println(<span class="hljs-string">&quot;生产者生产了&quot;</span> + i);                        buffer.notifyAll();                    &#125;                &#125;            &#125;        &#125;).start();        <span class="hljs-comment">//消费者</span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">synchronized</span> (buffer) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                        <span class="hljs-keyword">while</span> (head == tail) &#123;                            <span class="hljs-keyword">try</span> &#123;                                buffer.wait();                            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                                e.printStackTrace();                            &#125;                        &#125;                        System.out.println(<span class="hljs-string">&quot;消费者消费了&quot;</span> + buffer[head]);                        head = (head + <span class="hljs-number">1</span>) % CAPACITY;                        buffer.notifyAll();                    &#125;                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><h2 id="使用ReentrantLock实现"><a href="#使用ReentrantLock实现" class="headerlink" title="使用ReentrantLock实现"></a>使用<code>ReentrantLock</code>实现</h2><p>对比 ReentrantLock 和 synchronized 可以看出两者的差别（最后会总结二者的区别）</p><ul><li>synchronized 只能有一个阻塞队列，而 ReentrantLock 可以通过添加多个条件互斥量增加阻塞队列的个数</li></ul><p>使用 ReentrantLock 有一个注意的地方，要在在 finally 中关闭锁。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">private</span> Lock lock=<span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMethod</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span>&#123;            lock.lock();            <span class="hljs-comment">//code</span>        &#125;         <span class="hljs-keyword">finally</span>&#123;            lock.unlock();        &#125;       &#125;  &#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[CAPACITY];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Condition notFull = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Condition notEmpty = lock.newCondition();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//生产者</span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    lock.lockInterruptibly();                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                        <span class="hljs-keyword">while</span> ((tail + <span class="hljs-number">1</span>) % CAPACITY == head) &#123;                            <span class="hljs-keyword">try</span> &#123;                                notFull.await();                            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                                e.printStackTrace();                            &#125;                        &#125;                        buffer[tail] = i;                        tail = (tail + <span class="hljs-number">1</span>) % CAPACITY;                        System.out.println(<span class="hljs-string">&quot;生产者生产了&quot;</span> + i);                        notEmpty.signal();                    &#125;                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    lock.unlock();                &#125;            &#125;        &#125;).start();        <span class="hljs-comment">//消费者</span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    lock.lockInterruptibly();                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                        <span class="hljs-keyword">while</span> (head == tail) &#123;                            <span class="hljs-keyword">try</span> &#123;                                notEmpty.await();                            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                                e.printStackTrace();                            &#125;                        &#125;                        System.out.println(<span class="hljs-string">&quot;消费者消费了&quot;</span> + buffer[head]);                        head = (head + <span class="hljs-number">1</span>) % CAPACITY;                        notFull.signal();                    &#125;                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    lock.unlock();                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><h2 id="两种锁的区别"><a href="#两种锁的区别" class="headerlink" title="两种锁的区别"></a>两种锁的区别</h2><h3 id="区别一："><a href="#区别一：" class="headerlink" title="区别一："></a>区别一：</h3><p>synchronized 是通过虚拟机层面实现的，而 ReentrantLock 是通过 JDK API 实现的</p><h3 id="区别二：等待可中断"><a href="#区别二：等待可中断" class="headerlink" title="区别二：等待可中断"></a>区别二：等待可中断</h3><p>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可等待特性对处理执行时间非常长的同步块很有帮助。</p><p>具体说来，假如业务代码中有两个线程，Thread1 和 Thread2。假设 Thread1 获取了对象锁，Thread2 将等待 Thread1 释放锁。</p><ul><li>使用synchronized。如果 Thread1 不释放，Thread2 将一直等待，不能被中断。</li><li>使用ReentrantLock。如果 Thread1 不释放，Thread2 等待了很长时间以后，可以中断等待，转而去做别的事情。</li></ul><h3 id="区别三：公平锁"><a href="#区别三：公平锁" class="headerlink" title="区别三：公平锁"></a>区别三：公平锁</h3><p>公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不能保证这一点。非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁。 </p><ul><li><p>synchronized的锁是非公平锁</p></li><li><p>ReentrantLock默认情况下也是非公平锁，但可以通过带 boolean 的构造函数要求使用公平锁。</p></li></ul><h3 id="区别四：绑定多个条件"><a href="#区别四：绑定多个条件" class="headerlink" title="区别四：绑定多个条件"></a>区别四：绑定多个条件</h3><p>ReentrantLock可以同时绑定多个Condition对象，只需多次调用 <code>newCondition()</code> 方法即可。</p><p>synchronized中，锁对象的 <code>wait()</code> 和 <code>notify()</code>  或 <code>notifyAll()</code> 方法可以实现一个隐含的条件。如果需要多个条件，只能多加锁。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>专业书籍备忘录</title>
    <link href="/2019/12/05/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2019/12/05/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D.png?raw=true" alt></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从Comparable到compareTo方法</title>
    <link href="/2019/12/05/%E4%BB%8EComparable%E5%88%B0compareTo%E6%96%B9%E6%B3%95/"/>
    <url>/2019/12/05/%E4%BB%8EComparable%E5%88%B0compareTo%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>今天刷LeetCode <a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a> 需要用到 String 类型的排序问题，就具体看了一下 Java 的实现方法</p><p>String 是实现了 Comparable 接口，Comparable 接口里面只有一个方法就是 compareTo 方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(String anotherString)</span> </span>&#123;xxx&#125;</code></pre><p>我们来看一下文档说明</p><blockquote><p>按字典顺序比较两个字符串。比较是基于字符串中每个字符的 Unicode 值。</p><p>如果本身字符串对象的字典序在参数字符串之前返回负整数，之后返回正整数，相同返回 0。</p></blockquote><p>字典序是什么，返回值是怎么确定的呢？</p><blockquote><p>如果两个字符串字典序不同，则它们</p><ul><li>要么在某个索引处具有不同的字符（索引必须是两个字符串的有效索引），</li><li>要么它们的长度不同</li><li>或者以上两者都存在</li></ul><p>返回值确定如下:</p><ul><li>如果它们在一个或多个索引位置具有不同的字符，假设 k 表示第一个不相同字符，返回两个字符的差 <code>this.charAt(k)-anotherString .charAt(k)</code></li><li>如果没有字符不同，则按字典顺序，较短的字符串在较长的字符串之前，返回 <code>this.length()-anotherString.length()</code></li></ul></blockquote><p>我们拿出一个实现版本看一下它的实现逻辑</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] value, <span class="hljs-keyword">byte</span>[] other, <span class="hljs-keyword">int</span> len1, <span class="hljs-keyword">int</span> len2)</span> </span>&#123;    <span class="hljs-keyword">int</span> lim = Math.min(len1, len2);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; lim; k++) &#123;        <span class="hljs-keyword">if</span> (value[k] != other[k]) &#123;            <span class="hljs-keyword">return</span> getChar(value, k) - getChar(other, k);        &#125;    &#125;    <span class="hljs-keyword">return</span> len1 - len2;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从ACID到CAP/BASE</title>
    <link href="/2019/12/03/%E4%BB%8EACID%E5%88%B0CAP-BASE/"/>
    <url>/2019/12/03/%E4%BB%8EACID%E5%88%B0CAP-BASE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2019年11月29日 随笔</title>
    <link href="/2019/11/29/2019%E5%B9%B411%E6%9C%8829%E6%97%A5-%E9%9A%8F%E7%AC%94/"/>
    <url>/2019/11/29/2019%E5%B9%B411%E6%9C%8829%E6%97%A5-%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>今天北京下了2019年的第一场雪🌨，虽然不大，但是纷纷扬扬的场景还是让人心生欢喜。</p><p>这场早来的雪提醒我们，就连之间感觉很新鲜的2019年也都快要过去了。</p><p>2019年发生了什么事呢？</p><p>仔细想想好像没有发生什么太大的改变，但是好像也有一些什么不同。</p><p>在我的印象里2018年的下半年是黑色的，所以，我对着2019年有的不一样的期待，期待能把小论文赶快做出来，期待能学会很多新的技能，期待能去一线互联网公司实习，期待着能多读书等等等等。</p><p>好像期待的很多事都没有坚持下来，但是好像也有很多意外的收获，可能这就是人生吧，总不会让你一帆风顺，但是又总会在一些细枝末节的地方给你一点希望。</p><p>我总说，种一棵树最好的时间是十年前，其次就是现在，每次说完这句话，我都能重振旗鼓一段时间(至少有半天吧，我也不确定🤣)</p><p>最近我发现了一个我很不好的地方，当我的计划被打乱或者受挫的时候，我总是归结于自身之前的计划没有坚持下去，把所有的过错都推到了昨天的自己身上，让现在的自己获得一点心理安慰。</p><p>希望发现了这一点的我，能及时的改正一下吧，</p><p>人生总会有很多的不如意，晴有时风，阴有时雨，让自己快乐一点吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2019/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2019/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>待补充</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h2><h3 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h3><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p><p>定义一个二维数组 <code>dp</code> 存储最大价值，其中 <code>dp[i][j]</code> 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p><ul><li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，<code>dp[i][j] = dp[i-1][j]</code>。</li><li>第 i 件物品添加到背包中，<code>dp[i][j] = dp[i-1][j-w] + v</code>。</li></ul><p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v)</script><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        W 表示背包能容纳的最大重量</span><span class="hljs-comment">        N 表示物品的数量</span><span class="hljs-comment">        wiehgts 表示 N 件物品的重量</span><span class="hljs-comment">        value 表示 N 件物品的价值</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[] weights, <span class="hljs-keyword">int</span>[] values)</span> </span>&#123;        <span class="hljs-comment">//dp[i][j] 表示只放前 i 件的商品，体积不超过 j 的最大价值</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][W + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;            <span class="hljs-keyword">int</span> w = weights[i - <span class="hljs-number">1</span>];            <span class="hljs-keyword">int</span> v = values[i - <span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j++) &#123;                <span class="hljs-keyword">if</span> (j &gt;= w) &#123;                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - w] + v);                &#125; <span class="hljs-keyword">else</span> &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[N][W];    &#125;&#125;</code></pre><p><strong>我们以下面的物品举例说明求解的过程</strong></p><p><div align="left"> <img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E8%A1%A8%E5%8D%952.png?raw=true" width="274px" height="141px"> </div><br>下面以四个状态的计算举例</p><p><div align="left"> <img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E8%A1%A8%E5%8D%95.png?raw=true" width="1108px" height="535px"> </div></p><h3 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h3><p>观察状态转移方程或者填充表格的顺序，我们可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，表示容量为 j 时，可以获得的最大价值。</p><script type="math/tex; mode=display">dp[j] = max(dp[j],dp[j-w]+v)</script><p>值得注意的是，等号左边的<code>dp[j]</code>表示前 i 件商品容量为 j 时可以获得的最大价值，本质上是<code>dp[i][j]</code>；等号右边的<code>dp[j]</code>和<code>dp[j-w]</code>是前 i -1 件商品时容量分别为 j 和 j-w 时获得的最大价值，本质上其实是<code>dp[i-1][j]</code>和<code>dp[i-1][j-w]</code>。</p><p>如果我们实现代码的时候，内层循环还是按照容量从小到大循环，就会出现一个问题，就是<code>dp[j-w]</code>表示的不再是<code>dp[i-1][j-w]</code>而是<code>dp[i][j-w]</code>。</p><p>所以，我们实现的时候内层循环，要按照容量从大向小来循环。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[] weights, <span class="hljs-keyword">int</span>[] values)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[W + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;        <span class="hljs-keyword">int</span> w = weights[i - <span class="hljs-number">1</span>], v = values[i - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = W; j &gt;= <span class="hljs-number">1</span>; j--) &#123;            <span class="hljs-keyword">if</span> (j &gt;= w) &#123;                dp[j] = Math.max(dp[j], dp[j - w] + v);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[W];&#125;</code></pre><p>内容参考<a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92?id=_0-1-%e8%83%8c%e5%8c%85">Leetcode题解/动态规划/0-1-背包</a></p><h2 id="二维费用背包问题"><a href="#二维费用背包问题" class="headerlink" title="二维费用背包问题"></a>二维费用背包问题</h2><p>二维费用背包问题本质上只是0/1背包的变形，多添加一种费用。二维费用背包问题是指：</p><ul><li><p>对于每件物品，具有两种不同的费用和价值（比如一个物品既有体积又有重量，还有选择它得到的价值），选择这件物品必须同时付出这两种代价</p></li><li><p>对于每种代价都有一个可付出的最大值，也就是背包容量。</p></li><li><p>问怎样选择物品可以得到最大的价值。</p></li></ul><p>再次以背包问题为例：</p><p>有一个容量为 N 、承重为 W 的背包，要用这个背包装下物品的价值最大，这些物品有三个属性：体积 volume、重量 weight 和价值 value。</p><p>定义一个三维数组 <code>dp</code> 存储最大价值，其中 <code>dp[i][j][k]</code> 表示前 i 件物品体积不超过 j 重量不超过 k 时能获得的最大价值。</p><p>设第 i 件物品体积为 volume、重量为weight、价值为 value，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p><ul><li>第 i 件物品没添加到背包，体积不超过 j 重量不超过 k 的前 i 件物品的最大价值就是体积不超过 j 重量不超过 k 的前 i-1 件物品的最大价值，<code>dp[i][j][k] = dp[i-1][j][k]</code>。</li><li>第 i 件物品添加到背包中，<code>dp[i][j][k] = dp[i-1][j-volume][k-weight] + value</code>。</li></ul><p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p><script type="math/tex; mode=display">dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-volume][k-weight] + value)</script><p>同样压缩维度，我们可以获得二维数组下的，状态转移方程</p><script type="math/tex; mode=display">dp[j][k] = max(dp[j][k],dp[j-volume][k-weight] + value)</script><p>我们以 <a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a> 为例说明二维背包的解题过程</p><p>在这个问题中，每个字符串对应一个物品，每选择一个字符串就得花费一定量的 0 和 1，每个字符串的价值都是 1，0 和 1的最大容量为 m 和 n 。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">         dp[i][j] 表示当 i 个 0 和 j 个 1 时，所能收获的最大价值，也就是最多字符串的个数。</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (String str : strs) &#123;            <span class="hljs-keyword">int</span> one = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> zero = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;                <span class="hljs-keyword">if</span> (str.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>)                    zero++;                <span class="hljs-keyword">else</span>                    one++;            &#125;            <span class="hljs-comment">//为什么要逆序遍历，参考0/1 背包的解释。</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;= zero; i--) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= one; j--) &#123;                    dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;</code></pre><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包问题和 0/1 背包最大的不同，在于<strong>物品是可以重复选择的</strong>。</p><p>我们以 <a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a> 这道经典题目举例，说明完全背包问题的特点和求解方法。</p><p>我们同样定义一个二维数组<code>dp[i][j]</code> ， 表示考虑前 i <strong>种</strong>硬币，凑出金额为 j 的最少硬币数目。</p><p>所以每个硬币的面值不再是价值而是背包问题的费用，每种类型的硬币的价值都是 1。</p><p>这里出现了与 0/1 背包的<strong>第一个差别</strong>，0/1 背包只有两种选择拿或者不拿，可以理解为拿 0 个和拿 1 个。</p><p>而完全背包选择就多了，可以拿 1 个，2 个，3 个等等直到达到最大容量，所以状态转移方程为</p><script type="math/tex; mode=display">dp[i][j] = min(dp[i-1][j], dp[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)</script><p>c 表示第 i 种硬币的面值，也就是费用。</p><p>我们发现存在一定的重复计算</p><script type="math/tex; mode=display">dp[i][j-c] = min(dp[i-1][j-c], dp[i-1][j-2*c]+1, f[i-1][j-2*c]+3, ..., f[i-1][j-k*c]+(k+1))</script><p>结合上面两者</p><script type="math/tex; mode=display">dp[i][j] = min(dp[i-1][j],dp[i][j-c]+1)</script><p>分析上面的动态转移方程，我们可以看出来 只考虑前 i 种硬币，凑出金额为 j 的最少硬币数目可以由两种状态得到。</p><p>将二维压缩到一维</p><script type="math/tex; mode=display">dp[j] = min(dp[j], dp[j-c] + 1)</script><p>在这里我们可以完全背包和0/1背包的<strong>第二个不同</strong>，完全背包中<code>dp[j-c]</code>不再表示<code>dp[i-1][j-c]</code>而是<code>dp[i][j-c]</code>。为什么要强调这一点呢，因为这会导致我们的编程实现和 0/1 背包出现差异。</p><p>在 0/1 背包中，我们如果正序遍历背包容量，会导致<code>dp[i-1][j-c]</code>被<code>dp[i][j-c]</code>覆盖，所以我们要逆序遍历。</p><p>而在完全背包问题中，<code>dp[j-c]</code>表示的就是<code>dp[i][j-c]</code>，所以我们要正序遍历背包容量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>当物品个数有限时，我们采取逆序的循环遍历容量，如0/1背包问题。</p></li><li><p>当物品个数无限是，我们采用顺序的循环，如完全背包问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>646. 最长数对链</title>
    <link href="/2019/11/27/646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/"/>
    <url>/2019/11/27/646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">646. 最长数对链</a></h4><p>如何排列 pair 使得 pair 链最长，类似于👉<a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a>的经典问题-✍️<a href="https://en.wikipedia.org/wiki/Activity_selection_problem">活动选择问题</a></p><p>这类问题的贪心算法就是：</p><p>在现有的活动中选择「最早结束」的活动，对应到我们的这个问题，就是选择 pair 中第二位最小的数。</p><a id="more"></a><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.Comparator;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLongestChain</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] pairs)</span> </span>&#123;        <span class="hljs-keyword">if</span> (pairs == <span class="hljs-keyword">null</span> || pairs.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = pairs.length;        Arrays.sort(pairs, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] o1, <span class="hljs-keyword">int</span>[] o2)</span> </span>&#123;                <span class="hljs-keyword">if</span> (o1[<span class="hljs-number">0</span>] != o2[<span class="hljs-number">0</span>]) &#123;                    <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];                &#125;                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];            &#125;        &#125;);        <span class="hljs-keyword">int</span> a = Integer.MIN_VALUE;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] pair : pairs) &#123;            <span class="hljs-keyword">if</span> (pair[<span class="hljs-number">0</span>] &gt; a) &#123;                a = pair[<span class="hljs-number">1</span>];                cnt++;            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找的各种变形</title>
    <link href="/2019/11/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%98%E5%BD%A2/"/>
    <url>/2019/11/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%98%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找，寻找插入的位置"><a href="#二分查找，寻找插入的位置" class="headerlink" title="二分查找，寻找插入的位置"></a>二分查找，寻找插入的位置</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-comment">//开区间</span>    <span class="hljs-keyword">while</span> (l &lt; h) &#123;        <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[m] == k) &#123;            <span class="hljs-keyword">return</span> m;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &gt; k) &#123;            h = m;        &#125; <span class="hljs-keyword">else</span>            l = m + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> l;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala和Java的版本兼容问题</title>
    <link href="/2019/11/26/Scala-and-java-version-compatibility-issues/"/>
    <url>/2019/11/26/Scala-and-java-version-compatibility-issues/</url>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/1574740536160.png?raw=true" alt></p><p><a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html">JDK COMPATIBILITY</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark 共享变量的若干思考</title>
    <link href="/2019/11/26/reflections-on-Spark-shared-variables/"/>
    <url>/2019/11/26/reflections-on-Spark-shared-variables/</url>
    
    <content type="html"><![CDATA[<p>通常在向 Spark 传递函数时，可以使用 driver programme 中定义的变量，但是集群中运行的每个 tusk 都只会得到这些变量的一份新的副本，更新这些副本的值也不会影响driver programme 中的对应变量。</p><p>Spark 的两个共享变量，累加器与广播变量，使用结果聚合与广播这两种常见的通信模式突破了这一限制。<br><a id="more"></a></p><h2 id="Accumulator"><a href="#Accumulator" class="headerlink" title="Accumulator"></a>Accumulator</h2><h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><p>第一种共享变量，即累加器，提供了将 worker node 中的值聚合到 driver programme 中的简单语法。</p><p>下面的代码展示了一个 accumulator 被用于对一个数组中的元素求和:</p><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> accum = sc.longAccumulator(<span class="hljs-string">&quot;My Accumulator&quot;</span>)accum: org.apache.spark.util.<span class="hljs-type">LongAccumulator</span> = <span class="hljs-type">LongAccumulator</span>(id: <span class="hljs-number">0</span>, name: <span class="hljs-type">Some</span>(<span class="hljs-type">My</span> <span class="hljs-type">Accumulator</span>), value: <span class="hljs-number">0</span>)scala&gt; sc.parallelize(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)).foreach(x =&gt; accum.add(x))...<span class="hljs-number">10</span>/<span class="hljs-number">09</span>/<span class="hljs-number">29</span> <span class="hljs-number">18</span>:<span class="hljs-number">41</span>:<span class="hljs-number">08</span> <span class="hljs-type">INFO</span> <span class="hljs-type">SparkContext</span>: <span class="hljs-type">Tasks</span> finished in <span class="hljs-number">0.317106</span> sscala&gt; accum.valueres2: <span class="hljs-type">Long</span> = <span class="hljs-number">10</span></code></pre><p>可以通过调用 <code>SparkContext.longAccumulator()</code> 或 <code>SparkContext.doubleAccumulator()</code> 方法创建数值类型的 <code>accumulator</code>（累加器）以分别累加 Long 或 Double 类型的值。集群上正在运行的任务就可以使用 <code>add</code> 方法来累计数值。</p><p>注意，worker node 上的 tusk 不能访问累加器的值。从这些任务的角度来看，累加器是一个只写变量。只有 driver program 才可以使用 <code>value</code> 方法读取累加器的值。</p><h3 id="累加器与容错"><a href="#累加器与容错" class="headerlink" title="累加器与容错"></a>累加器与容错</h3><p>Spark 会自动重新执行失败的或较慢的仕务来应对有错的或着比较慢的机器。例如，如果对某分区执行 <code>map()</code> 操作的节点失败了，Spark 会在另一个节点上重新运行该任务。即使该节点没有崩溃，而只是处理速度比别的节点慢很多，Spark 也可以抢占式地在另一个节点上启动一个“投机”（speculative）型的任务副本，如果该任务更早结束就可以直接获取结果。即使没有节点失败，Spark有时也需要重新运行任务来获取缓存中被移除出内存的数据。</p><p><em>因此最终结果就是同一个函数可能对同一个数据运行了多次。</em></p><p>这种情况下累加器要怎么处理呢？</p><p>实际结果是，对于要在 action 操作中使用的累加器，Spark只会把每个任务对累加器的修改应用一次。</p><p>因此，如果想要一个无论在失败还是重复计算时都绝对可靠的累加器，我们必须把它放在 <code>foreach()</code> 这样的 action 操作中。对于在 RDD  transform 操作中使用的累加器，就不能保证有这种情况了。transform 操作中累加器可能会发生不止一次更新。</p><p>举个例子，当一个被缓存下来但是没有经常使用的RDD在第一次从 LRU 缓存中被移除并又被重新用到时，这种非预期的累加器的多次更新就会发生。</p><h2 id="Broadcast-Variables"><a href="#Broadcast-Variables" class="headerlink" title="Broadcast Variables"></a>Broadcast Variables</h2><p>Spark 的第二种共享变量是<em>广播变量</em>，它可以让程序高效的向所有的 worker node 发送一个较大的 只读值。比如，你的应用需要向所有的节点发送一个较大的只读查询表，甚至是机器学习算法中的一个很大的特征向量，这个时候广播变量就会很好用了。</p><p>如果你对闭包有了解，你会发现，Spark 会自动把闭包中所有引用到的变量发送到 worker node上。这虽然很方便，但也很低效。原因有二：</p><ul><li>默认的任务发送机制是专门为小任务进行优化的，当发送的共享数据量较大时效率较低</li><li>事实上你可能会在多个操作中使用同一个变量，但是Spark会为每个操作分别发送。</li></ul><p>广播变量通过在一个变量 <code>v</code> 上调用 <code>SparkContext.broadcast(v)</code> 方法来进行创建。广播变量是 <code>v</code> 的一个 wrapper（包装器），可以通过调用 <code>value</code> 方法来访问它的值。代码示例如下:</p><pre><code class="hljs scala"><span class="hljs-comment">// 这里的 v 指的是 Array(1, 2, 3)</span>scala&gt; <span class="hljs-keyword">val</span> broadcastVar = sc.broadcast(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))broadcastVar: org.apache.spark.broadcast.<span class="hljs-type">Broadcast</span>[<span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>]] = <span class="hljs-type">Broadcast</span>(<span class="hljs-number">0</span>)scala&gt; broadcastVar.valueres0: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下的Spark程序开发环境配置</title>
    <link href="/2019/11/25/Spark-program-development-environment-configuration-under-Windows/"/>
    <url>/2019/11/25/Spark-program-development-environment-configuration-under-Windows/</url>
    
    <content type="html"><![CDATA[<p>在Windows环境下, 使用IDEA进行Spark程序开发所需的环境配置, 主要是Maven pom文件的配置和Scala SDK的配置。<br><a id="more"></a></p><h3 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h3><p>需要配置<code>Maven home directory</code>、<code>User settings file</code>、<code>Local repository</code>、 <code>Import Maven projects automatically</code></p><h2 id="IDEA-Maven工程创建与配置"><a href="#IDEA-Maven工程创建与配置" class="headerlink" title="IDEA Maven工程创建与配置"></a>IDEA Maven工程创建与配置</h2><h3 id="配置pom-xml文件"><a href="#配置pom-xml文件" class="headerlink" title="配置pom.xml文件"></a>配置<code>pom.xml</code>文件</h3><p><strong>spark精简版的pom.xml</strong></p><p><a href="https://github.com/apache/spark/blob/master/examples/pom.xml">https://github.com/apache/spark/blob/master/examples/pom.xml</a></p><p><strong>spark最全版的pom.xml</strong></p><p><a href="https://github.com/apache/spark/blob/master/pom.xml">https://github.com/apache/spark/blob/master/pom.xml</a></p><p><strong>maven repository</strong></p><p><a href="https://mvnrepository.com/search?q=spark">https://mvnrepository.com/search?q=spark</a></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>TestSpark<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.kfk.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>TestSpark<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scala.version</span>&gt;</span>2.11.12<span class="hljs-tag">&lt;/<span class="hljs-name">scala.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scala.binary.version</span>&gt;</span>2.11<span class="hljs-tag">&lt;/<span class="hljs-name">scala.binary.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">spark.version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">spark.version</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-core_$&#123;scala.binary.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-streaming_$&#123;scala.binary.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-sql_$&#123;scala.binary.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-hive_$&#123;scala.binary.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-streaming-kafka-0-10_$&#123;scala.binary.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h3 id="导入Scala-SDK"><a href="#导入Scala-SDK" class="headerlink" title="导入Scala SDK"></a>导入<code>Scala SDK</code></h3><p><code>groupId</code>和<code>artifactId</code>被统称为“坐标”是为了保证项目唯一性而提出的</p><p><code>groupId</code>一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。举个apache公司的tomcat项目例子：这个项目的<code>groupId</code>是org.apache</p><p>artifactId表示这个项目的名称</p><p>包结构最好是<code>groupId.artifactId.xxx</code></p><h2 id="编写spark程序"><a href="#编写spark程序" class="headerlink" title="编写spark程序"></a>编写spark程序</h2><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.spark.test<span class="hljs-keyword">import</span> org.apache.spark.&#123;<span class="hljs-type">SparkConf</span>, <span class="hljs-type">SparkContext</span>&#125;<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MyScalaWordCout</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;    <span class="hljs-comment">//参数检查</span>    <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">2</span>) &#123;      <span class="hljs-type">System</span>.err.println(<span class="hljs-string">&quot;Usage: MyWordCout    &quot;</span>)      <span class="hljs-type">System</span>.exit(<span class="hljs-number">1</span>)    &#125;    <span class="hljs-comment">//获取参数</span>    <span class="hljs-keyword">val</span> input=args(<span class="hljs-number">0</span>)    <span class="hljs-keyword">val</span> output=args(<span class="hljs-number">1</span>)    <span class="hljs-comment">//创建scala版本的SparkContext</span>    <span class="hljs-keyword">val</span> conf=<span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setAppName(<span class="hljs-string">&quot;myWordCount&quot;</span>)    <span class="hljs-keyword">val</span> sc=<span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(conf)    <span class="hljs-comment">//读取数据</span>    <span class="hljs-keyword">val</span> lines=sc.textFile(input)    <span class="hljs-comment">//进行相关计算</span>    <span class="hljs-keyword">val</span> resultRdd=lines.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>)).map((_,<span class="hljs-number">1</span>)).reduceByKey(_+_)    <span class="hljs-comment">//保存结果</span>    resultRdd.saveAsTextFile(output)    sc.stop()  &#125;&#125;</code></pre><h2 id="打成jar包然后上传到服务器"><a href="#打成jar包然后上传到服务器" class="headerlink" title="打成jar包然后上传到服务器"></a>打成jar包然后上传到服务器</h2><pre><code class="hljs bash">bin/spark-submit --master <span class="hljs-built_in">local</span>[2] /opt/jars/sparkStu.jar hdfs://bigdata-pro01.kfk.com:9000/user/data/stu.txt</code></pre><pre><code class="hljs bash">./bin/spark-submit \  --class &lt;main-class&gt; \  --master &lt;master-url&gt; \  --deploy-mode &lt;deploy-mode&gt; \  --conf &lt;key&gt;=&lt;value&gt; \  ... <span class="hljs-comment"># other options</span>  &lt;application-jar&gt; \  [application-arguments]</code></pre><p>Some of the commonly used options are:</p><blockquote><ul><li><code>--class</code>: The entry point for your application (e.g. <code>org.apache.spark.examples.SparkPi</code>)</li><li><code>--master</code>: The <a href="https://spark.apache.org/docs/latest/submitting-applications.html#master-urls">master URL</a> for the cluster (e.g. <code>spark://23.195.26.187:7077</code>)</li><li><code>--deploy-mode</code>: Whether to deploy your driver on the worker nodes (<code>cluster</code>) or locally as an external client (<code>client</code>) (default: <code>client</code>) <strong>†</strong></li><li><code>--conf</code>: Arbitrary Spark configuration property in key=value format. For values that contain spaces wrap “key=value” in quotes (as shown).</li><li><code>application-jar</code>: Path to a bundled jar including your application and all dependencies. The URL must be globally visible inside of your cluster, for instance, an <code>hdfs://</code> path or a <code>file://</code> path that is present on all nodes.</li><li><code>application-arguments</code>: Arguments passed to the main method of your main class, if any</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello world</title>
    <link href="/2019/11/25/first-blog/"/>
    <url>/2019/11/25/first-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>昨天花了一些时间搭建了 hexo 的框架，打算慢慢的从知乎转移到个人博客了。</p><p>为什么想要写博客呢，一方面是想要记录自己的成长，看着自己学会、总结的东西越来越多，还是很有成就感的；另一方面是想要留下点东西，帮助别人吧，把自己踩过的坑，走过的弯路以及经验分享给别人吧。</p><p>写博客是一个慢活，得精雕细琢，这对于我这个急性子是一个挺大的挑战。希望写博客能帮我客服一下这个毛病吧。</p><p>最后的最后希望，我能一直坚持下去，不断的输入和不断的输出。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
