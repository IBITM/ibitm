<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/2019/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>设计模式</strong>是软件设计中常见问题或者常见应用场景的典型解决方案。 每个模式就像一张蓝图， 你可以通过对其进行定制来解决代码中的特定设计问题。</p>
<p>发现一个整理比较号的文档 <a href="https://refactoringguru.cn/design-patterns/what-is-pattern" target="_blank" rel="noopener">设计模式</a></p>
<h2 id="模式的分类"><a href="#模式的分类" class="headerlink" title="模式的分类"></a>模式的分类</h2><p>不同设计模式在其复杂程度、 细节层次以及在整个系统中的应用范围等方面各不相同。 我喜欢将其类比于道路的建造： 如果你希望让十字路口更加安全， 那么可以安装一些交通信号灯， 或者修建包含行人地下通道在内的多层互通式立交桥。</p>
<p>最基础的、 底层的模式通常被称为<em>惯用技巧</em>。 这类模式一般只能在一种编程语言中使用。</p>
<p>最通用的、 高层的模式是<em>构架模式</em>。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。</p>
<p>此外， 所有模式可以根据其<em>意图</em>或目的来分类。 本书覆盖了三种主要的模式类别：</p>
<ul>
<li><strong>创建型模式</strong>提供创建对象的机制， 增加已有代码的灵活性和可复用性。</li>
<li><strong>结构型模式</strong>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li>
<li><strong>行为模式</strong>负责对象间的高效沟通和职责委派。</li>
</ul>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>单例模式同时解决了两个问题， 所以违反了<a href="https://refactoringguru.cn/didp/principles/solid-principles/srp" target="_blank" rel="noopener">单一职责原则</a>：</p>
<ol>
<li><p><strong>保证一个类只有一个实例</strong>。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</p>
<p>它的运作方式是这样的： 如果你创建了一个对象， 同时一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p>
<p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它<strong>必须</strong>总是返回一个新对象。</p>
</li>
</ol>
<p>客户端甚至可能没有意识到它们一直都在使用同一个对象。</p>
<ol>
<li><p><strong>为该实例提供一个全局访问入口 </strong>。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p>
<p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p>
<p>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p>
</li>
</ol>
<p>如今， 单例模式已经变得非常流行， 以至于人们会将只解决上文描述中任意一个问题的东西称为<em>单例</em>。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>所有单例的实现都包含以下两个相同的步骤：</p>
<ul>
<li>将默认构造函数设为私有， 防止其他对象使用单例类的 <code>new</code>运算符。</li>
<li>新建一个静态方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ul>
<p>如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。</p>
<h4 id="单例模式适用性"><a href="#单例模式适用性" class="headerlink" title="单例模式适用性"></a>单例模式适用性</h4><ol>
<li><p>如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。</p>
<p>单例模式禁止通过除了特殊构建方法以外的任何方式来创建自身类对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象</p>
</li>
<li><p>如果你需要更加严格地控制全局变量， 可以使用单例模式。</p>
<p>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p>
</li>
</ol>
<h4 id="经典的实现方法"><a href="#经典的实现方法" class="headerlink" title="经典的实现方法"></a>经典的实现方法</h4><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>易</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>{}  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p><strong>是否 Lazy 初始化：</strong>否</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>易</p>
<p>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>{}  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h5><p><strong>JDK 版本：</strong>JDK1.5 起</p>
<p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>较复杂</p>
<p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) {</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。</p>
<p>你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。</p>
<p>在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。</p>
<p>代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。</p>
<p>这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。</p>
<h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><p>a） 为服务类和代理类提供的公共接口或抽象类</p>
<p>b） 服务类具体实现逻辑，实现或继承接口</p>
<p>c）  代理类，实现或继承接口，有对服务类实例的引用，调用服务类实例业务的具体实现</p>
<p>d） 客户端，调用代理类实现对服务类的调用</p>
<p><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/structure.png" alt="代理设计模式的结构"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 相关问题的总结</title>
    <url>/2019/12/15/Maven-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Maven中建立的依赖管理方式基本已成为Java语言依赖管理的事实标准，Maven的替代者Gradle也基本沿用了Maven的依赖管理机制。在Maven依赖管理中，唯一标识一个依赖项是由该依赖项的三个属性构成的，分别是groupId、artifactId以及version。这三个属性可以唯一确定一个组件（Jar包或者War包）。</p>
<p>其实在Nexus仓库中，一个仓库一般分为public(Release)仓和SNAPSHOT仓，前者存放正式版本，后者存放快照版本。如果在项目配置文件中（无论是build.gradle还是pom.xml）指定的版本号带有’-SNAPSHOT’后缀，比如版本号为’Junit-4.10-SNAPSHOT’，那么打出的包就是一个快照版本。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>秒杀系统学习笔记</title>
    <url>/2019/12/15/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h2><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p><a href="https://spring.io/projects/spring-boot/" target="_blank" rel="noopener">Spring Boot 官网</a></p>
<p><a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">Spring Boot 构建一个 RESTFUL 风格的 Web 服务</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>关于计算机网络的知识点复习...</title>
    <url>/2019/12/14/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>既然已经决定要做开发了，就把之间放下的东西捡起来好好看看吧😝</p>
<h2 id="ISO-OSI-参考模型和-TCP-IP-模型"><a href="#ISO-OSI-参考模型和-TCP-IP-模型" class="headerlink" title="ISO/OSI 参考模型和 TCP/IP 模型"></a>ISO/OSI 参考模型和 TCP/IP 模型</h2><p>国际标准化组织 (ISO)提出了网络体系结构模型，称为<strong>开放互连参考模型</strong>（OSI/RM），简称为 <strong>OSI 参考模型</strong>。</p>
<p>共有七层</p>
<h2 id="数据交换的方式"><a href="#数据交换的方式" class="headerlink" title="数据交换的方式"></a>数据交换的方式</h2><ol>
<li><p>电路交换</p>
<p>在源节点和目的节点之间建立一条专用（双方独占）的通路用于传送数据，通常分为三个阶段：建立连接，传输数据和断开连接。最典型的电路交换网就是传统电话网络。</p>
<p>主要特点是整个报文的比特流连续的从源点到达终点，好像在一个管道中传输。优点是数据直接传送、延迟小。缺点是线路利用率低、不能充分利用线路容量。</p>
</li>
<li><p>报文交换</p>
<p>将用户数据附加上源地址、目的地址、校验码等辅助信息，封装成报文。整个报文传送到相邻节点，全部存储袭来后，再转发给下一个节点，重复上述过程直到到达目的节点。</p>
<p>报文交换也称为存储-转发。主要特点是整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p>
<p>优点是可以较为充分线路容量；可以实现不同链路之间不同数据率的转换；可以实现格式转换；可以实现一对多、多对一的访间；可以实现差错控制。其缺点是增加了资源开销（如辅助信息导致处理时间和存储资源的开销）：增加缓冲延迟；额外的控制机制来保证多个报文的顺序不会乱序；缓冲区难以管理，因为报文的大小不确定，接收方在接收到报文之前不能预知报文的大小。</p>
</li>
<li><p>分组交换<br>分组交换网络，也称为包交换网络。其原理是将用户数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输。</p>
<p>除了具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均延迟更小，网络中占用的平均缓冲区更少；更易于标准化；更适合应用。</p>
</li>
</ol>
<p>现在的主流网络基本上都可以看成是<strong>分组交换</strong>网络。</p>
<h2 id="端到端的通信和点到点的通信的区别？"><a href="#端到端的通信和点到点的通信的区别？" class="headerlink" title="端到端的通信和点到点的通信的区别？"></a>端到端的通信和点到点的通信的区别？</h2><p> 三点不同：</p>
<ul>
<li>实体不同</li>
<li>发生的层不同</li>
<li>点到点不支持可靠传输，而端到端支持</li>
</ul>
<p>从本质上说，由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，而传输层为网络中的主机提供端到端的通信。</p>
<p>直接相连的结点之间的通信叫点到点通信。它只提件一合却票到另一台机器之间的通信，不会涉及程序或进程的概念。同时点到点通信并不能保证数据传输的可靠性，也不能说明源主机与目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。</p>
<p>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到点通信更高一级的通信方式，以完成应用程序（进程）之间的通信。“端”是指用户程序的端口，端口号标识了应用层中不同的进程。</p>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><h3 id="单工通信"><a href="#单工通信" class="headerlink" title="单工通信"></a>单工通信</h3><p>只能有一个方向的通信，没有反方向的交互，只需要一个信道。</p>
<h3 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h3><p>通信的双方都可以发送或者接受消息，但是任何一方不能同时发送和接收消息，需要两个信道。</p>
<h3 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h3><p>通信的双方都可以同时发送和接收消息，需要两个信道。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>计算网络</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 年年底，关于面试的一些总结</title>
    <url>/2019/12/14/2019-%E5%B9%B4%E5%B9%B4%E5%BA%95%EF%BC%8C%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<p>这一周面试了腾讯和百度的「数据开发」岗，对这个岗位有了更加清楚的认识和定位，数据开发岗就是为大数据的全生命周期提供服务，包括数据产生，传输，建模，统计</p>
<p>分析，实验评估，可视化的全流程。</p>
<p>负责的工作主要包括：</p>
<ul>
<li><p>前期的工作主要就是 ETL，将数据从来源端经过抽取（extract）、转换（transform）、加载（load）到数据库中的过程。</p>
<p>这部分可能需要掌握一些数据库的基本理论、SQL 以及大数据组件的使用和调优，比如 Hadoop，Hive和HBase，很少会涉及组件的大规模二次开发</p>
</li>
<li><p>中期工作就是数据分析，通过上一个过程获得的数据，开始建模分析，以达到一定的目的。</p>
<p>这部分通常是使用机器学习算法（但不限于机器学习算法）来达到建模分析的目的。</p>
<p>这部分工作和数学建模中的「数据题」的解答过程很像。</p>
</li>
<li><p>结果展示</p>
<p>一般就是指 BI 报表、可视化或者可行性分析。</p>
</li>
</ul>
<p>因为不同部门对于数据开发的定义和负责的工作不太一样，我根据我的认识将数据开发岗和其他的岗位进行一下对比</p>
<p><strong>算法工程师</strong></p>
<blockquote>
<p>数据开发或者说数据分析岗位和算法岗有相似的地方，也有不同的地方</p>
<p>两者都需要使用机器学习算法对数据进行建模分析，但是算法工程师中算法的使用会直接上线，作用到生产环境中。而数据分析的算法是在离线环境下进行的，是为了分析业务结果而进行。</p>
<p>举一个不恰当的例子，拿某新闻 APP 举例，新闻组的推荐算法是直接作用到业务上的，会决定你推荐的结果，而数据分析负责的工作是当新闻 APP 的用户日使用量出现下降时，我们使用算法来分析为什么会出现用户日使用量的下降。数据分析师的算法并不会直接作用到业务，而是挖掘数据中的信息，为了理解业务而进行的。</p>
<p>并且技术栈也会有明显不同，数据开发对于大数据组件的使用和调优、以及SQL的使用要求更高，而算法工程师则是算法的设计、实现、调参有更高的要求，主要是对于编程能力和数学功底的要求。</p>
</blockquote>
<p><strong>数据仓库工程师</strong></p>
<blockquote>
<p>数据仓库岗与数据开发岗的关系更像是数据开发的进阶版。数据仓库开发人员还要参与数据仓库 ETL 流程设计、开发和优化，解决 ETL 过程相关技术问题</p>
<p>这就在数据开发岗的要求之上，要求数据仓库开发人员熟悉数据仓库各类模型建模理论，了解数据仓库数据分层架构，多维数据模型设计，理论性更强一些。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2019/12/12/ConcurrentHashMap/</url>
    <content><![CDATA[<h2 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span><<span class="title">K</span>,<span class="title">V</span>> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry<K,V> next;</K,V></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap引入了一个分段的概念（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）</p>
<p>Segment 继承自 ReentrantLock。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span><<span class="title">K</span>,<span class="title">V</span>> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() > <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry<K,V>[] table;</K,V></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment<K,V>[] segments;</K,V></span><br></pre></td></tr></tbody></table></figure>
<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的结构我们可以了解到，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。</p>
<p>第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</p>
<p><strong>坏处</strong></p>
<p>这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长</p>
<p><strong>好处</strong></p>
<p>写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上）。</p>
<p>所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</p>
<h3 id="Size方法"><a href="#Size方法" class="headerlink" title="Size方法"></a>Size方法</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></tbody></table></figure>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment<K,V>[] segments = <span class="keyword">this</span>.segments;</K,V></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            }</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < segments.length; ++j) {</span><br><span class="line">                Segment<K,V> seg = segmentAt(segments, j);</K,V></span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) {</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c < <span class="number">0</span> || (size += c) < <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (retries > RETRIES_BEFORE_LOCK) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二、JDK-8"><a href="#二、JDK-8" class="headerlink" title="二、JDK 8"></a>二、JDK 8</h2><p>JDK8 中彻底放弃了 Segment 转而采用的是 Node ，其设计思想也不再是 JDK7 中的分段锁思想。</p>
<p>在 JDK8 中 ConcurrentHashMap 利用 CAS + Synchronized 来确保线程安全，它的底层数据结构依然是数组+链表+红黑树。</p>
<h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap核心数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node<K,V>[] table;</K,V></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时才会用的一个临时数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node<K,V>[] nextTable;</K,V></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表初始化和大小调整控件</span></span><br><span class="line"><span class="comment"> * -1 表示正在初始化</span></span><br><span class="line"><span class="comment"> * -n 表示有n-1的线程正在扩容.  </span></span><br><span class="line"><span class="comment"> * 当 table 为空时, 用来存储要初始化的表的值的大小</span></span><br><span class="line"><span class="comment"> * 当 table 已经初始化以后，表示用来调整表大小的值</span></span><br><span class="line"><span class="comment"> * 总之，sizeCtl 为正和为负表示截然不同的概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize的时候下一个需要处理的元素下标为index=transferIndex-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过CAS无锁更新，ConcurrentHashMap元素总数，但不是准确值</span></span><br><span class="line"><span class="comment">// 因为多个线程同时更新会导致部分线程更新失败，失败时会将元素数目变化存储在counterCells中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize或者创建CounterCells时的一个标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存储元素变动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="Unsafe-compareAndSwapXXX-方法"><a href="#Unsafe-compareAndSwapXXX-方法" class="headerlink" title="Unsafe.compareAndSwapXXX 方法"></a>Unsafe.compareAndSwapXXX 方法</h4><p><code>Unsafe.compareAndSwapXXX()</code> 方法是 sun.misc.Unsafe 类中的方法，因为在 ConcurrentHashMap 中大量使用了这些方法。其声明如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapXXX</span><span class="params">(type1 object, type2 offset, type4 expect, type5 update)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>方法的伪逻辑如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (object[offset].value equal expect) {</span><br><span class="line">    object[offset].value = update;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">} <span class="keyword">else</span> </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>CAS方法都是native方法，可以保证原子性，并且效率比synchronized高。 </p>
<p>关于CAS方法的原理，建议参考一下两篇博客，强烈推荐</p>
<p><a href="http://www.dataguru.cn/java-865024-1-1.html" target="_blank" rel="noopener">http://www.dataguru.cn/java-865024-1-1.html</a></p>
<p><a href="https://www.cnblogs.com/Mainz/p/3546347.html" target="_blank" rel="noopener">https://www.cnblogs.com/Mainz/p/3546347.html</a></p>
<h4 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h >>> <span class="number">16</span>)) & HASH_BITS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>h ^ (h >>> 16) 在计算 hash 的时候 key.hashCode() 的高位也参与运算，这部分跟 HashMap 计算方法一致，不同的是 h ^ (h >>> 16) 计算结果 & 上 0x7fffffff ，从而保证结果一定为正整数。获得 hash 之后，通过hash & (n -1)计算下标。</p>
<p>为什么要多添加一个与操作呢，看后面的注释</p>
<blockquote>
<p>usable bits of normal node hash</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br></pre></td></tr></tbody></table></figure>
<p>ConcurrentHashMap 中的元素节点总结一下有这么几种可能：</p>
<ul>
<li><p>null </p>
</li>
<li><p>Node<k, v> 普通节点，可以组成单向链表，hash > 0</k,></p>
</li>
<li><p>TreeBin<k,v> 红黑树节点，TreeBin 是对 TreeNode 的封装，其 hash 为 TREEBIN = -2。</k,v></p>
<p>HashMap 和 ConcurrentHashMap 的 TreeNode 实现并不相同。</p>
<p>在 HashMap 中 TreeNode 封装了红黑树所有的操作方法，而 ConcurrentHashMap 中红黑树操作的方法都封装在 TreeBin 中，TreeBin 相当于一个红黑树容器，容器中的红黑树节点为 TreeNode 。</p>
<p>HashMap 可以直接在 tab[i] 存入 TreeNode ，而 ConCurrentHashMap 只能在 tab[i] 存入 TreeBin 。</p>
</li>
<li><p>ForwardingNode<k,v> key 和 value 都为 null 的一个特殊节点，用于 resize 操作填充已经完成迁移操作的节点。FrowardingNode 的hash在初始化的时候被置成MOVED = -1</k,v></p>
<p>在 resize 过程中当发现 tab[i] 上是 ForwardingNode 的时候（通过hash判断）就可知 tab[i] 已经迁移完了，直接跳过该节点去处理其它节点。</p>
<p>ConcurrentHashMap禁止 node 的 key 或 value 为 null 或许跟该节点的存在也是有一定关系的。</p>
</li>
<li><p>ReservationNode<k,v>只在 compute 和 computeIfAbsent 中使用，其hash为RESERVED = -3</k,v></p>
</li>
</ul>
<p>从上面的总结可以看出普通节点hash为正整数是有意义的，hash > 0是判断该节点是否为链表节点（普通节点）的一个重要依据。</p>
<h4 id="get-set-update-tab-i-方法"><a href="#get-set-update-tab-i-方法" class="headerlink" title="get/set/update tab[i] 方法"></a>get/set/update tab[i] 方法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取tab[i]节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <K,V> <span class="function">Node<K,V> <span class="title">tabAt</span><span class="params">(Node<K,V>[] tab, <span class="keyword">int</span> i)</K,V></span> </K,V></span>{</K,V></span><br><span class="line">    <span class="keyword">return</span> (Node<K,V>)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i << ASHIFT) + ABASE);</K,V></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// compare and swap tab[i]，期望值是c，tab[i].value == c ? tab[i] = v : return false</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <K,V> <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node<K,V>[] tab, <span class="keyword">int</span> i, Node<K,V> c, Node<K,V> v)</K,V></K,V></K,V></span> </span>{</K,V></span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i << ASHIFT) + ABASE, c, v);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置tab[i] = v</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <K,V> <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node<K,V>[] tab, <span class="keyword">int</span> i, Node<K,V> v)</K,V></K,V></span> </span>{</K,V></span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i << ASHIFT) + ABASE, v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="size-方法"><a href="#size-方法" class="headerlink" title="size() 方法"></a>size() 方法</h4><p>ConcurrentHashMap中baseCount用于保存tab中元素总数，但是并不准确，因为多线程同时增删改，会导致baseCount修改失败，此时会将元素变动存储于counterCells数组内。</p>
<p>当需要统计当前的size的时候，除了要统计baseCount之外，还需要统计counterCells中的元素变化。</p>
<p>值得一提的是即使如此，统计出来的依旧不是当前tab中元素的准确值，在多线程环境下统计前后并不能stop the world暂停线程操作，因此无法保证准确性。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n < <span class="number">0L</span>) ? <span class="number">0</span> : (n > (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>)n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>{</span><br><span class="line">    CounterCell[] as = counterCells; </span><br><span class="line">    CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="comment">// 除了baseCount以外，部分元素变化存储在counterCells数组中</span></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历数组累加获得结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < as.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="put-putIfAbsent方法"><a href="#put-putIfAbsent方法" class="headerlink" title="put/putIfAbsent方法"></a>put/putIfAbsent方法</h4><p>现在对put(putVal)方法做一个总结:</p>
<ol>
<li>如果待插入的键值对中 key 或 value 为 null，抛出异常，结束。否则执行2</li>
<li>如果 table 为 null，则进行初始化操作 initTable()，否则执行3</li>
<li>如果 table[i] 为空，则用 CAS 在 table[i] 头结点直接插入，如果 CAS 执行成功，退出插入操作，执行步骤 7；如果 CAS 失败,则说明有其他节点已经插入，执行4</li>
<li>此时判断，hash 值是否为 MOVED(-1)，如果是则说明其他有其他线程在执行扩容操作，帮助他们一起扩容，来提高性能。如果没有在扩容,那么执行5</li>
<li>判断 hash 的值，如果>=0，则在链表合适的位置插入，否则，查看 table[i] 是否是红黑树结构，如果是，则在红黑树适当位置插入。到此时，值对已经顺利插入，接下来执行6</li>
<li>如果 table[i] 节点数binCount不为0，判断它此时的状态,是否需要转变为红黑树</li>
<li>执行 addcount(1L, binCount)</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="comment">// 核心是调用putVal方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果key存在就不更新value</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="comment">// key或value 为null都是不允许的，因为Forwarding Node就是key和value都为null，是用作标志位的。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 根据key计算hash值，有了hash就可以计算下标了</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 可能需要初始化或扩容，因此一次未必能完成插入操作，所以添加上for循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node<K,V>[] tab = table;;) {</K,V></span><br><span class="line">        Node<K,V> f;  <span class="comment">//用来存储要插入的键值对</span></K,V></span><br><span class="line">        <span class="comment">// i 表示要插入的下标, fh 表示要要插入的键值对的 hash 值</span></span><br><span class="line">        <span class="keyword">int</span> n, i, fh; </span><br><span class="line">        <span class="comment">// 表还没有初始化，先初始化，lazily initialized</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 根据hash计算应该插入的index</span></span><br><span class="line">        <span class="comment">// table[i]为空,用CAS在table[i]头结点直接插入,退出插入操作;</span></span><br><span class="line">        <span class="comment">// 如果CAS失败,则有其他节点已经插入,继续下一步</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) & hash)) == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node<K,V>(hash, key, value, <span class="keyword">null</span>)))</K,V></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// MOVED for forwarding nodes</span></span><br><span class="line">        <span class="comment">// 说明f为ForwardingNode，只有扩容的时候才会有ForwardingNode出现在tab中，因此可以断定该tab正在进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)  </span><br><span class="line">            <span class="comment">// 协助扩容            </span></span><br><span class="line">            tab = helpTransfer(tab, f);   </span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 对链表头结点上锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) </span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) </span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (fh >= <span class="number">0</span>) { <span class="comment">// 是链表节点</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node<K,V> e = f;; ++binCount) </K,V></span><br><span class="line">                        {</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 遍历链表查找是否包含该元素</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash && ((ek = e.key) == key || (ek != <span class="keyword">null</span> && key.equals(ek)))) </span><br><span class="line">                            {</span><br><span class="line">                                oldVal = e.val;  <span class="comment">// 保存旧的值用于当做返回值</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;  <span class="comment">// 替换旧的值为新值</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                            Node<K,V> pred = e;</K,V></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) </span><br><span class="line">                            {</span><br><span class="line">                                <span class="comment">// 遍历链表，如果一直没找到，则新建一个Node放到链表结尾</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node<K,V>(hash, key, value, <span class="keyword">null</span>);</K,V></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) <span class="comment">// 是红黑树节点</span></span><br><span class="line">                    { </span><br><span class="line">                        Node<K,V> p;</K,V></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 去红黑树查找该元素，如果没找到就添加，找到了就返回该节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) {</K,V></span><br><span class="line">                            <span class="comment">// 保存旧的value用于返回</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value; <span class="comment">// 替换旧的值</span></span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) </span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (binCount >= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 链表长度超过阈值（默认为8），则需要将链表转为一棵红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 如果只是替换，并未带来节点的增加则直接返回旧的value即可</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 元素总数加1，并且判断是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// check<0不检查resize, check<="1只在没有线程竞争的情况下检查resize</span"></0不检查resize,></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>{</span><br><span class="line">    CounterCell[] as; </span><br><span class="line">    <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// counterCells数组不为null       </span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        <span class="comment">// CAS更新BASECOUNT失败（有其它线程更新了BASECOUNT，baseCount已经不是最新值）</span></span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) </span><br><span class="line">    {</span><br><span class="line">        CounterCell a; </span><br><span class="line">        <span class="keyword">long</span> v; </span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// counterCells为null</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) < <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// counterCells对应位置为null，这里不是很懂，有没有大神解答下？</span></span><br><span class="line">            <span class="comment">// ThreadLocalRandom.getProbe() 获得线程探测值，什么用途？</span></span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() & m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">// 更新CELLVALUE失败</span></span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {</span><br><span class="line">            <span class="comment">// 初始化counterCells</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// counterCells != null 或者 BASECOUNT CAS更新失败都是因为有线程竞争，因此不检查resize</span></span><br><span class="line">        <span class="keyword">if</span> (check <= <span class="number">1</=></span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 统计下ConcurrentHashMap元素总数    </span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (check >= <span class="number">0</span>) {</span><br><span class="line">        Node<K,V>[] tab, nt; <span class="keyword">int</span> n, sc;</K,V></span><br><span class="line">        <span class="comment">// 元素总数大于sizeCtl</span></span><br><span class="line">        <span class="keyword">while</span> (s >= (<span class="keyword">long</span>)(sc = sizeCtl) && (tab = table) != <span class="keyword">null</span> && (n = tab.length) < MAXIMUM_CAPACITY) {</span><br><span class="line">            <span class="comment">// 获取一个resize标志位   </span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// sizeCtl < 0 表示table正在初始化或者resize</span></span><br><span class="line">            <span class="keyword">if</span> (sc < <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> || transferIndex <= <span class="number">0</=></span>)<br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 当前线程是第一个发起扩容操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。</span></span><br><span class="line"><span class="comment"> * 所以执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，</span></span><br><span class="line"><span class="comment"> * 有且只有一个线程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node<K,V>[] initTable() {</K,V></span><br><span class="line">    Node<K,V>[] tab; </K,V></span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) < <span class="number">0</span>) <span class="comment">//sizeCtl 为负值时，表示线程在初始化或者扩容</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">int</span> n = (sc > <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node<K,V>[] nt = (Node<K,V>[])<span class="keyword">new</span> Node<?,?>[n];</K,V></K,V></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n >>> <span class="number">2</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="resize相关方法：resizeStamp、helpTransfer、transfer"><a href="#resize相关方法：resizeStamp、helpTransfer、transfer" class="headerlink" title="resize相关方法：resizeStamp、helpTransfer、transfer"></a>resize相关方法：resizeStamp、helpTransfer、transfer</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个标志位，该标志位经过RESIZE_STAMP_SHIFT左移必定为负数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// Integer.numberOfLeadingZeros返回n对应32位二进制数左侧0的个数，如9（1001）返回28  </span></span><br><span class="line">    <span class="comment">// 1 << (RESIZE_STAMP_BITS - 1) = 2^15，其中RESIZE_STAMP_BITS固定为16</span></span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> << (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> table是一个链表数组，默认为空，初始化操作延迟到了第一次执行put，默认大小DEFAULT_CAPACITY=16 ,执行扩容后，总为2的n次幂</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span><<span class="title">K</span>,<span class="title">V</span>> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span><<span class="title">K</span>,<span class="title">V</span>> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node<K,V> next;</K,V></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val) {</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node<K,V> next) {</K,V></span><br><span class="line">        <span class="keyword">this</span>(hash, key, val);</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>     </span>{ <span class="keyword">return</span> key; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>   </span>{ <span class="keyword">return</span> val; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{ <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Helpers.mapEntryToString(key, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>{</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        Object k, v, u; Map.Entry<?,?> e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &&</span><br><span class="line">                (k = (e = (Map.Entry<?,?>)o).getKey()) != <span class="keyword">null</span> &&</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &&</span><br><span class="line">                (k == key || k.equals(key)) &&</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>上面提到，初始化操作发生在第一次put操作，那么多个线程执行put时，如何保证只执行一次初始化呢?</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开始执行插入操作</span></span><br><span class="line">    <span class="keyword">for</span> (Node<K,V>[] tab = table;;) {</K,V></span><br><span class="line">        Node<K,V> f; </K,V></span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">       <span class="comment">//如果table为空,执行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//table[i]为空,用CAS在table[i]头结点直接插入,退出插入操作;如果CAS失败,则有其他节点已经插入,继续下一步</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) & hash)) == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node<K,V>(hash, key, value, <span class="keyword">null</span>)))</K,V></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果table[i]不为空,且table[i]的hash值为-1,则有其他线程在执行扩容操作,帮助他们一起扩容,提高性能</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">       <span class="comment">//如果没有在扩容</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) {</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) {</span><br><span class="line">                    <span class="comment">//fh(table[i])的hash>=0,则此时table[i]为链表结构,找到合适位置插入</span></span><br><span class="line">                    <span class="keyword">if</span> (fh >= <span class="number">0</span>) {</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node<K,V> e = f;; ++binCount) {</K,V></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &&</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> && key.equals(ek)))) {</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                            Node<K,V> pred = e;</K,V></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) {</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node<K,V>(hash, key,</K,V></span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">//fh(table[i])的hash<0,table[i]为红黑树结构,这个过程采用同步内置锁实现并发< span></0,table[i]为红黑树结构,这个过程采用同步内置锁实现并发<></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) {</span><br><span class="line">                        Node<K,V> p;</K,V></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,</K,V></span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) {</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }<span class="comment">//到此时,已将键值对插入到了合适的位置,检查链表长度是否超过阈值,若是,则转变为红黑树结构</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (binCount >= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//count+1,如有必要,则扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></span></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。</p>
<p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p>
<p>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。<br>2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。<br>3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。<br>4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。<br>5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2019/12/12/HashMap/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的部分内容参考<a href="https://link.zhihu.com/?target=https%3A//cyc2018.github.io/CS-Notes/%23/notes/Java%20%E5%AE%B9%E5%99%A8%3Fid%3Dhashmap">cyc2018.github.io/CS-Notes/HashMap</a>，结合本人理解和JDK1.8进行了部分的更改，如果有理解或者编辑错误，望指出。</p>
<h2 id="一、存储结构"><a href="#一、存储结构" class="headerlink" title="一、存储结构"></a>一、存储结构</h2><p>HashMap内部维护了一个Node类型的数组</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node<K,V>[] table;</K,V></span><br></pre></td></tr></tbody></table></figure>
<p>Node 类是 HashMap 的一个静态内部类，主要是由4个字段，从 next 字段我们可以看出 Node 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决地址冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Node。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span><<span class="title">K</span>,<span class="title">V</span>> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span><<span class="title">K</span>,<span class="title">V</span>> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node<K,V> next;</K,V></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node<K,V> next) {</K,V></span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>{ <span class="keyword">return</span> key; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>{ <span class="keyword">return</span> value; }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>{ <span class="keyword">return</span> key + <span class="string">"="</span> + value; }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>{</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) {</span><br><span class="line">            Map.Entry<?,?> e = (Map.Entry<?,?>)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &&</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用拉链法进行查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<h2 id="二、如何确定桶的下标"><a href="#二、如何确定桶的下标" class="headerlink" title="二、如何确定桶的下标"></a>二、如何确定桶的下标</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h >>> <span class="number">16</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//n 是当前的容量</span></span><br><span class="line">p = tab[i = (n - <span class="number">1</span>) & hash]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="为什么要这样计算哈希值？"><a href="#为什么要这样计算哈希值？" class="headerlink" title="为什么要这样计算哈希值？"></a>为什么要这样计算哈希值？</h3><p><a href="https://zhuanlan.zhihu.com/p/76784693" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76784693</a></p>
<h3 id="为什么链表数组的长度为偶数"><a href="#为什么链表数组的长度为偶数" class="headerlink" title="为什么链表数组的长度为偶数"></a>为什么链表数组的长度为偶数</h3><p>通过hash值计算桶的下标的时候，我们本应该是</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">p = tab[i = hash % n]</span><br></pre></td></tr></tbody></table></figure>
<p>但是Java中的实现却是</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">p = tab[i = (n - <span class="number">1</span>) & hash]</span><br></pre></td></tr></tbody></table></figure>
<p>令 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></tbody></table></figure>
<p>令一个数 y 与 x-1 做「与」运算</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y & (x-1) : 00000010</span><br></pre></td></tr></tbody></table></figure>
<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">y   : 10110010</span><br><span class="line">x   : 00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></tbody></table></figure>
<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<h2 id="三、put操作"><a href="#三、put操作" class="headerlink" title="三、put操作"></a>三、put操作</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">    Node<K,V>[] tab; </K,V></span><br><span class="line">    Node<K,V> p; </K,V></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//1.先判断链表数组是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//2.确定桶下标</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) & hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//3.使用拉链法解决地址冲突</span></span><br><span class="line">        Node<K,V> e; </K,V></span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">//3.1判断是否是相同的key，需要进行覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash && ((k = p.key) == key || (key != <span class="keyword">null</span> && key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//3.2.1 如果当前桶的链表已经被组织成红黑树了，调用红黑树的putTreeVal方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode<K,V>)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</K,V></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//3.2.2 遍历链表插入节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount >= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &&((k = e.key) == key || (key != <span class="keyword">null</span> && key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//4.判断是否扩容</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size > threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="四、扩容后重新计算下标"><a href="#四、扩容后重新计算下标" class="headerlink" title="四、扩容后重新计算下标"></a>四、扩容后重新计算下标</h2><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">capacity     : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></tbody></table></figure>
<p>对于一个 Key，</p>
<ul>
<li>它的哈希值如果在第 5 位上为 0，那么扩容后的下标和之前一样；</li>
<li>如果为 1，那么扩容后的下标为原来的下标 +16。</li>
</ul>
<p>我们可以通过下面代码，判断是否需要扩容</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e.hash & oldCap) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//说明e.hash对应oldCap二进制为1的那一位为0，桶的下标不变</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//下标变为oldIndex + oldCap</span></span><br></pre></td></tr></tbody></table></figure>
<p>举一个具体的例子</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">第一个键值对的hash值的二进制为 <span class="number">10001</span>(<span class="number">17</span>) 对应的下标为 <span class="number">17</span> % <span class="number">16</span> =<span class="number">1</span></span><br><span class="line">第二个键值对的hash值的二进制为 <span class="number">00001</span>(<span class="number">1</span>) 对应的下标为 <span class="number">1</span> % <span class="number">16</span> =<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>原数组长度 capacity 为 16 时，这两个键值对都应该放在同一个桶里面，但是扩容后</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">第一个键值对的hash值的二进制为 <span class="number">10001</span>(<span class="number">17</span>) 对应的下标为 <span class="number">17</span> % <span class="number">32</span> = <span class="number">17</span></span><br><span class="line">第二个键值对的hash值的二进制为 <span class="number">00001</span>(<span class="number">1</span>) 对应的下标为 <span class="number">1</span> % <span class="number">32</span> = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="五、扩容"><a href="#五、扩容" class="headerlink" title="五、扩容"></a>五、扩容</h2><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<p>capacity</p>
<blockquote>
<p>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</p>
</blockquote>
<p>size</p>
<blockquote>
<p>键值对数量</p>
</blockquote>
<p>threshold</p>
<blockquote>
<p>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</p>
</blockquote>
<p>loadFactor</p>
<blockquote>
<p>装载因子，table 能够使用的比例，threshold = (int)(newCapacity * loadFactor)。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> << <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></tbody></table></figure>
<p>resize 方法主要用来初始化链表数组或者让链表数组的长度变为原来的2倍.</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node<K,V>[] resize() {</K,V></span><br><span class="line">    Node<K,V>[] oldTab = table;</K,V></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.如果容量不为0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap > <span class="number">0</span>) </span><br><span class="line">    {   <span class="comment">//1.1判断容量是否已经到了最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap >= MAXIMUM_CAPACITY) {</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//1.2 如果没有到达最大容量，就将容量变为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap << <span class="number">1</span>) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr << <span class="number">1</span>; </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr > <span class="number">0</span>)  <span class="comment">//如果是指定初始容量的话，使用阈值去初始化->这种是针对有参数的构造方法</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> {   </span><br><span class="line">        <span class="comment">//2.如果是初始化，使用DEFAULT_INITIAL_CAPACITY来初始化容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) { <span class="comment">//这点没太看懂</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap < MAXIMUM_CAPACITY && ft < (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?(<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>({<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>})</span><br><span class="line">    <span class="comment">//3、创建一个新的链表数组，开始一点一点的搬运</span></span><br><span class="line">        Node<K,V>[] newTab = (Node<K,V>[])<span class="keyword">new</span> Node[newCap];</K,V></K,V></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < oldCap; ++j) {</span><br><span class="line">            Node<K,V> e;</K,V></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) {</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash & (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode<K,V>)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</K,V></span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    Node<K,V> loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</K,V></span><br><span class="line">                    Node<K,V> hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</K,V></span><br><span class="line">                    Node<K,V> next;</K,V></span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash & oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) {</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>日志分析系统</title>
    <url>/2019/12/08/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h2 id="项目所用的组件版本"><a href="#项目所用的组件版本" class="headerlink" title="项目所用的组件版本"></a>项目所用的组件版本</h2><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Zookeeper 两个最重要的系统模型：ZNode 和 Watcher</p>
<h3 id="ZNode"><a href="#ZNode" class="headerlink" title="ZNode"></a>ZNode</h3><p>在 Zookeeper 中节点有三种类型：</p>
<ul>
<li>持久节点（persistent）</li>
<li>临时节点（ephemeral）</li>
<li>顺序节点</li>
</ul>
<p>在节点创建过程中，通过组合使用，可是生成 4 种组合型节点</p>
<p><strong>持久节点</strong></p>
<p>持久节点是指数据节点创建后，就会一直存在 Zookeeper 服务器上，直到有删除操作删除这个节点。</p>
<p><strong>临时节点</strong></p>
<p>与持久节点不同，临时节点的生命周期与客户端的会话联系在一起。也就说，如果客户端会话失效，那么这个客户端创建的临时节点就会被删除。</p>
<h3 id="Watcher-数据变更的通知"><a href="#Watcher-数据变更的通知" class="headerlink" title="Watcher - 数据变更的通知"></a>Watcher - 数据变更的通知</h3><p>Zookeeper 通过 Watcher 机制提供了一种分布式数据订阅/发布功能。Zookeeper 允许客户端在一个节点上注册一个 Watcher 事件监听，一旦一些事务对这个节点做一些操作，就会触发了这个 Watcher，客户端就会收到一个事件通知。</p>
<p>理解了 ZNode 和 Watcher 基本上就能大致了解 Zookeeper 的运行机制。</p>
<h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><h3 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a>预分区</h3><h3 id="RowKey-设计"><a href="#RowKey-设计" class="headerlink" title="RowKey 设计"></a>RowKey 设计</h3><p>在 HBase 中一条记录的唯一标识就是 rowkey ，那么这条数据存储于哪个 region，取决于 rowkey 处于哪个一个预分区的区间内。</p>
<p><strong>设计 rowkey 的主要目的 ，就是让数据均匀的分布于所有的 region 中，在一定程度上防止数据倾斜。</strong></p>
<h4 id="rowkey-长度原则"><a href="#rowkey-长度原则" class="headerlink" title="rowkey 长度原则"></a>rowkey 长度原则</h4><p>Rowkey 是一个二进制码流，Rowkey 的长度被很多开发者建议说设计在 10~100 个字节，不过建议是越短越好，不要超过 16 个字节，存为byte[]字节数组，<strong>一般设计成定长的</strong>。</p>
<p>原因如下：</p>
<ol>
<li>数据的持久化文件 HFile 中是按照 KeyValue 存储的，如果 Rowkey 过长比如 100 个字 节，1000 万列数据光 Rowkey 就要占用 100*1000 万=10 亿个字节，将近 1G 数据，这会极大 影响 HFile 的存储效率；</li>
<li>MemStore 将缓存部分数据到内存，如果 Rowkey 字段过长内存的有效利用率会降低， 系统将无法缓存更多的数据，这会降低检索效率。因此 Rowkey 的字节长度越短越好。</li>
<li>目前操作系统是都是 64 位系统，内存 8 字节对齐。控制在 16 个字节，8 字节的整数 倍利用操作系统的最佳特性。</li>
</ol>
<h4 id="rowkey-散列原则"><a href="#rowkey-散列原则" class="headerlink" title="rowkey 散列原则"></a>rowkey 散列原则</h4><p>如果 Rowkey 是按时间戳的方式递增，不要将时间放在二进制码的前面，建议将 Rowkey 的高位作为散列字段，由程序循环生成，低位放时间字段，这样将提高数据均衡分布在每个 RegionServer 实现负载均衡的几率。</p>
<p>如果没有散列字段，首字段直接是时间信息将产生所有 新数据都在一个 RegionServer 上堆积的热点现象，这样在做数据检索的时候负载将会集中 在个别 RegionServer，降低查询效率。</p>
<p>row key是按照<strong>字典序</strong>存储，因此，设计row key时，要充分利用这个排序特点，将经常一起读取的数据存储到一块，将最近可能会被访问的数据放在一块。</p>
<p>举个例子：如果最近写入HBase表中的数据是最可能被访问的，可以考虑将时间戳作为row key的一部分，由于是字典序排序，所以可以使用 <code>Long.MAX_VALUE - timestamp</code> 作为rowkey，这样能保证新写入的数据在读取时可以被快速命中。</p>
<h4 id="rowkey-唯一原则"><a href="#rowkey-唯一原则" class="headerlink" title="rowkey 唯一原则"></a>rowkey 唯一原则</h4><p>必须在设计上保证其唯一性。rowkey 是按照字典顺序排序存储的，因此，设计 rowkey 的时候，要充分利用这个排序的特点，将经常读取的数据存储到一块，将最近可能会被访问 的数据放到一块。</p>
<p>在日志数据中，用户 id 有 16 位左右，时间是 8 位，当前时间是 <code>System.currentTimeMillis()</code>不足16位，补 0. </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRowKeyGenerator</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getUUIDKey(String prefix) <span class="keyword">throws</span> UnsupportedEncodingException {</span><br><span class="line">        <span class="keyword">return</span> (prefix + UUID.randomUUID().toString()).getBytes(<span class="string">"UTF8"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getRandomKey(String prefix) <span class="keyword">throws</span> UnsupportedEncodingException {</span><br><span class="line">        <span class="keyword">return</span> (prefix + String.valueOf(<span class="keyword">new</span> Random().nextLong())).getBytes(<span class="string">"UTF8"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getTimestampKey(String prefix) <span class="keyword">throws</span> UnsupportedEncodingException {</span><br><span class="line">        <span class="keyword">return</span> (prefix + String.valueOf(System.currentTimeMillis())).getBytes(<span class="string">"UTF8"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getNanoTimestampKey(String prefix) <span class="keyword">throws</span> UnsupportedEncodingException {</span><br><span class="line">        <span class="keyword">return</span> (prefix + String.valueOf(System.nanoTime())).getBytes(<span class="string">"UTF8"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 自定义 RowKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getKfkRowKey(String userid,String datetime)<span class="keyword">throws</span> UnsupportedEncodingException {</span><br><span class="line">        <span class="keyword">return</span> (userid + datetime + String.valueOf(System.currentTimeMillis())).getBytes(<span class="string">"UTF8"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>大数据</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>使用两种锁实现带有环形缓冲区的生产者消费者模型</title>
    <url>/2019/12/08/The_producer-consumer_model_with_ring_buffers_is_implemented_using_two_types_of_locks/</url>
    <content><![CDATA[<h2 id="使用synchronized关键字"><a href="#使用synchronized关键字" class="headerlink" title="使用synchronized关键字"></a>使用<code>synchronized</code>关键字</h2><p>我们使用<strong>双指针</strong>法构建了一个环形缓冲区，使用环形缓冲区有几个需要注意的地方</p>
<ul>
<li><p>其中 head 表示缓冲区的开始，tail 表示缓冲区的结束，[head,tail) 前闭后开表示缓冲区中有数据的空间。</p>
<ul>
<li>初始化 head = tail = 0 表示缓冲区为空</li>
<li>随着生产物品 tail 不断的增加 <code>tail = (tail + 1) % CAPACITY</code></li>
<li>直到 <code>(tail + 1) % CAPACITY == head</code>表示缓冲区满</li>
</ul>
</li>
<li><p>有一个空间会被空置，作为缓冲区满的判断标志，所以真正的容量为 CAPACITY - 1。</p>
</li>
</ul>
<p>其次，关于 synchronized 关键字有几个需要注意的地方</p>
<ul>
<li>synchronized 是要结合 <code>Object.wait()</code> 和 <code>Object.notify</code> 或者 <code>Object.notifyAll()</code> 使用，具体说明请看文章 <a href="https://zhuanlan.zhihu.com/p/76625784" target="_blank" rel="noopener">为什么wait()和notify()需要搭配synchonized关键字使用?</a></li>
<li>因为 synchronized 只有一个阻塞队列，当多生产者多消费者时，唤醒时需要使用 <code>Object.notifyAll()</code></li>
<li>还有就是可能会出现的中断异常 InterruptedException 。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] buffer = <span class="keyword">new</span> <span class="keyword">int</span>[CAPACITY];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (buffer) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                        <span class="keyword">while</span> ((tail + <span class="number">1</span>) % CAPACITY == head) {</span><br><span class="line">                            <span class="keyword">try</span> {</span><br><span class="line">                                buffer.wait();</span><br><span class="line">                            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        buffer[tail] = i;</span><br><span class="line">                        tail = (tail + <span class="number">1</span>) % CAPACITY;</span><br><span class="line">                        System.out.println(<span class="string">"生产者生产了"</span> + i);</span><br><span class="line">                        buffer.notifyAll();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (buffer) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                        <span class="keyword">while</span> (head == tail) {</span><br><span class="line">                            <span class="keyword">try</span> {</span><br><span class="line">                                buffer.wait();</span><br><span class="line">                            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        System.out.println(<span class="string">"消费者消费了"</span> + buffer[head]);</span><br><span class="line">                        head = (head + <span class="number">1</span>) % CAPACITY;</span><br><span class="line">                        buffer.notifyAll();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用ReentrantLock实现"><a href="#使用ReentrantLock实现" class="headerlink" title="使用ReentrantLock实现"></a>使用<code>ReentrantLock</code>实现</h2><p>对比 ReentrantLock 和 synchronized 可以看出两者的差别（最后会总结二者的区别）</p>
<ul>
<li>synchronized 只能有一个阻塞队列，而 ReentrantLock 可以通过添加多个条件互斥量增加阻塞队列的个数</li>
</ul>
<p>使用 ReentrantLock 有一个注意的地方，要在在 finally 中关闭锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//code</span></span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">finally</span>{</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }   </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] buffer = <span class="keyword">new</span> <span class="keyword">int</span>[CAPACITY];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock.lockInterruptibly();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                        <span class="keyword">while</span> ((tail + <span class="number">1</span>) % CAPACITY == head) {</span><br><span class="line">                            <span class="keyword">try</span> {</span><br><span class="line">                                notFull.await();</span><br><span class="line">                            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        buffer[tail] = i;</span><br><span class="line">                        tail = (tail + <span class="number">1</span>) % CAPACITY;</span><br><span class="line">                        System.out.println(<span class="string">"生产者生产了"</span> + i);</span><br><span class="line">                        notEmpty.signal();</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    lock.lockInterruptibly();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) {</span><br><span class="line">                        <span class="keyword">while</span> (head == tail) {</span><br><span class="line">                            <span class="keyword">try</span> {</span><br><span class="line">                                notEmpty.await();</span><br><span class="line">                            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        System.out.println(<span class="string">"消费者消费了"</span> + buffer[head]);</span><br><span class="line">                        head = (head + <span class="number">1</span>) % CAPACITY;</span><br><span class="line">                        notFull.signal();</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="两种锁的区别"><a href="#两种锁的区别" class="headerlink" title="两种锁的区别"></a>两种锁的区别</h2><h3 id="区别一："><a href="#区别一：" class="headerlink" title="区别一："></a>区别一：</h3><p>synchronized 是通过虚拟机层面实现的，而 ReentrantLock 是通过 JDK API 实现的</p>
<h3 id="区别二：等待可中断"><a href="#区别二：等待可中断" class="headerlink" title="区别二：等待可中断"></a>区别二：等待可中断</h3><p>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可等待特性对处理执行时间非常长的同步块很有帮助。</p>
<p>具体说来，假如业务代码中有两个线程，Thread1 和 Thread2。假设 Thread1 获取了对象锁，Thread2 将等待 Thread1 释放锁。</p>
<ul>
<li>使用synchronized。如果 Thread1 不释放，Thread2 将一直等待，不能被中断。</li>
<li>使用ReentrantLock。如果 Thread1 不释放，Thread2 等待了很长时间以后，可以中断等待，转而去做别的事情。</li>
</ul>
<h3 id="区别三：公平锁"><a href="#区别三：公平锁" class="headerlink" title="区别三：公平锁"></a>区别三：公平锁</h3><p>公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不能保证这一点。非公平锁在锁被释放时，任何一个等待锁的线程都有机会获得锁。 </p>
<ul>
<li><p>synchronized的锁是非公平锁</p>
</li>
<li><p>ReentrantLock默认情况下也是非公平锁，但可以通过带 boolean 的构造函数要求使用公平锁。</p>
</li>
</ul>
<h3 id="区别四：绑定多个条件"><a href="#区别四：绑定多个条件" class="headerlink" title="区别四：绑定多个条件"></a>区别四：绑定多个条件</h3><p>ReentrantLock可以同时绑定多个Condition对象，只需多次调用 <code>newCondition()</code> 方法即可。</p>
<p>synchronized中，锁对象的 <code>wait()</code> 和 <code>notify()</code>  或 <code>notifyAll()</code> 方法可以实现一个隐含的条件。如果需要多个条件，只能多加锁。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>专业书籍备忘录</title>
    <url>/2019/12/05/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D.png?raw=true" alt></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>从Comparable到compareTo方法</title>
    <url>/2019/12/05/%E4%BB%8EComparable%E5%88%B0compareTo%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天刷LeetCode <a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">179. 最大数</a> 需要用到 String 类型的排序问题，就具体看了一下 Java 的实现方法</p>
<p>String 是实现了 Comparable 接口，Comparable 接口里面只有一个方法就是 compareTo 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>{xxx}</span><br></pre></td></tr></tbody></table></figure>
<p>我们来看一下文档说明</p>
<blockquote>
<p>按字典顺序比较两个字符串。比较是基于字符串中每个字符的 Unicode 值。</p>
<p>如果本身字符串对象的字典序在参数字符串之前返回负整数，之后返回正整数，相同返回 0。</p>
</blockquote>
<p>字典序是什么，返回值是怎么确定的呢？</p>
<blockquote>
<p>如果两个字符串字典序不同，则它们</p>
<ul>
<li>要么在某个索引处具有不同的字符（索引必须是两个字符串的有效索引），</li>
<li>要么它们的长度不同</li>
<li>或者以上两者都存在</li>
</ul>
<p>返回值确定如下:</p>
<ul>
<li>如果它们在一个或多个索引位置具有不同的字符，假设 k 表示第一个不相同字符，返回两个字符的差 <code>this.charAt(k)-anotherString .charAt(k)</code></li>
<li>如果没有字符不同，则按字典顺序，较短的字符串在较长的字符串之前，返回 <code>this.length()-anotherString.length()</code></li>
</ul>
</blockquote>
<p>我们拿出一个实现版本看一下它的实现逻辑</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other, <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k < lim; k++) {</span><br><span class="line">        <span class="keyword">if</span> (value[k] != other[k]) {</span><br><span class="line">            <span class="keyword">return</span> getChar(value, k) - getChar(other, k);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从ACID到CAP/BASE</title>
    <url>/2019/12/03/%E4%BB%8EACID%E5%88%B0CAP-BASE/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>2019年11月29日 随笔</title>
    <url>/2019/11/29/2019%E5%B9%B411%E6%9C%8829%E6%97%A5-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>今天北京下了2019年的第一场雪🌨，虽然不大，但是纷纷扬扬的场景还是让人心生欢喜。</p>
<p>这场早来的雪提醒我们，就连之间感觉很新鲜的2019年也都快要过去了。</p>
<p>2019年发生了什么事呢？</p>
<p>仔细想想好像没有发生什么太大的改变，但是好像也有一些什么不同。</p>
<p>在我的印象里2018年的下半年是黑色的，所以，我对着2019年有的不一样的期待，期待能把小论文赶快做出来，期待能学会很多新的技能，期待能去一线互联网公司实习，期待着能多读书等等等等。</p>
<p>好像期待的很多事都没有坚持下来，但是好像也有很多意外的收获，可能这就是人生吧，总不会让你一帆风顺，但是又总会在一些细枝末节的地方给你一点希望。</p>
<p>我总说，种一棵树最好的时间是十年前，其次就是现在，每次说完这句话，我都能重振旗鼓一段时间(至少有半天吧，我也不确定🤣)</p>
<p>最近我发现了一个我很不好的地方，当我的计划被打乱或者受挫的时候，我总是归结于自身之前的计划没有坚持下去，把所有的过错都推到了昨天的自己身上，让现在的自己获得一点心理安慰。</p>
<p>希望发现了这一点的我，能及时的改正一下吧，</p>
<p>人生总会有很多的不如意，晴有时风，阴有时雨，让自己快乐一点吧。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2019/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>待补充</p>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h2><h3 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h3><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p>定义一个二维数组 <code>dp</code> 存储最大价值，其中 <code>dp[i][j]</code> 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<ul>
<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，<code>dp[i][j] = dp[i-1][j]</code>。</li>
<li>第 i 件物品添加到背包中，<code>dp[i][j] = dp[i-1][j-w] + v</code>。</li>
</ul>
<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>
<script type="math/tex; mode=display">
dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v)</script><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        W 表示背包能容纳的最大重量</span></span><br><span class="line"><span class="comment">        N 表示物品的数量</span></span><br><span class="line"><span class="comment">        wiehgts 表示 N 件物品的重量</span></span><br><span class="line"><span class="comment">        value 表示 N 件物品的价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i][j] 表示只放前 i 件的商品，体积不超过 j 的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= n; i++) {< span><br><span class="line">            <span class="keyword">int</span> w = weights[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = values[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j <= w; j++) {< span><br><span class="line">                <span class="keyword">if</span> (j >= w) {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[N][W];</span><br><span class="line">    }</span><br><span class="line">}</span><br></=></span></=></span></pre></td></tr></tbody></table></figure>
<p><strong>我们以下面的物品举例说明求解的过程</strong></p>
<p></p><div align="left"> <img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E8%A1%A8%E5%8D%952.png?raw=true" width="274px" height="141px"> </div><br>下面以四个状态的计算举例<p></p>
<p></p><div align="left"> <img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E8%A1%A8%E5%8D%95.png?raw=true" width="1108px" height="535px"> </div><p></p>
<h3 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h3><p>观察状态转移方程或者填充表格的顺序，我们可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，表示容量为 j 时，可以获得的最大价值。</p>
<script type="math/tex; mode=display">
dp[j] = max(dp[j],dp[j-w]+v)</script><p>值得注意的是，等号左边的<code>dp[j]</code>表示前 i 件商品容量为 j 时可以获得的最大价值，本质上是<code>dp[i][j]</code>；等号右边的<code>dp[j]</code>和<code>dp[j-w]</code>是前 i -1 件商品时容量分别为 j 和 j-w 时获得的最大价值，本质上其实是<code>dp[i-1][j]</code>和<code>dp[i-1][j-w]</code>。</p>
<p>如果我们实现代码的时候，内层循环还是按照容量从小到大循环，就会出现一个问题，就是<code>dp[j-w]</code>表示的不再是<code>dp[i-1][j-w]</code>而是<code>dp[i][j-w]</code>。</p>
<p>所以，我们实现的时候内层循环，要按照容量从大向小来循环。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= n; i++) {< span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j >= <span class="number">1</span>; j--) {</span><br><span class="line">            <span class="keyword">if</span> (j >= w) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">}</span><br></=></span></pre></td></tr></tbody></table></figure>
<p>内容参考<a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92?id=_0-1-%e8%83%8c%e5%8c%85" target="_blank" rel="noopener">Leetcode题解/动态规划/0-1-背包</a></p>
<h2 id="二维费用背包问题"><a href="#二维费用背包问题" class="headerlink" title="二维费用背包问题"></a>二维费用背包问题</h2><p>二维费用背包问题本质上只是0/1背包的变形，多添加一种费用。二维费用背包问题是指：</p>
<ul>
<li><p>对于每件物品，具有两种不同的费用和价值（比如一个物品既有体积又有重量，还有选择它得到的价值），选择这件物品必须同时付出这两种代价</p>
</li>
<li><p>对于每种代价都有一个可付出的最大值，也就是背包容量。</p>
</li>
<li><p>问怎样选择物品可以得到最大的价值。</p>
</li>
</ul>
<p>再次以背包问题为例：</p>
<p>有一个容量为 N 、承重为 W 的背包，要用这个背包装下物品的价值最大，这些物品有三个属性：体积 volume、重量 weight 和价值 value。</p>
<p>定义一个三维数组 <code>dp</code> 存储最大价值，其中 <code>dp[i][j][k]</code> 表示前 i 件物品体积不超过 j 重量不超过 k 时能获得的最大价值。</p>
<p>设第 i 件物品体积为 volume、重量为weight、价值为 value，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<ul>
<li>第 i 件物品没添加到背包，体积不超过 j 重量不超过 k 的前 i 件物品的最大价值就是体积不超过 j 重量不超过 k 的前 i-1 件物品的最大价值，<code>dp[i][j][k] = dp[i-1][j][k]</code>。</li>
<li>第 i 件物品添加到背包中，<code>dp[i][j][k] = dp[i-1][j-volume][k-weight] + value</code>。</li>
</ul>
<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>
<script type="math/tex; mode=display">
dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-volume][k-weight] + value)</script><p>同样压缩维度，我们可以获得二维数组下的，状态转移方程</p>
<script type="math/tex; mode=display">
dp[j][k] = max(dp[j][k],dp[j-volume][k-weight] + value)</script><p>我们以 <a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a> 为例说明二维背包的解题过程</p>
<p>在这个问题中，每个字符串对应一个物品，每选择一个字符串就得花费一定量的 0 和 1，每个字符串的价值都是 1，0 和 1的最大容量为 m 和 n 。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         dp[i][j] 表示当 i 个 0 和 j 个 1 时，所能收获的最大价值，也就是最多字符串的个数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) {</span><br><span class="line">            <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < str.length(); i++) {</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(i) == <span class="string">'0'</span>)</span><br><span class="line">                    zero++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    one++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//为什么要逆序遍历，参考0/1 背包的解释。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i >= zero; i--) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j >= one; j--) {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包问题和 0/1 背包最大的不同，在于<strong>物品是可以重复选择的</strong>。</p>
<p>我们以 <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a> 这道经典题目举例，说明完全背包问题的特点和求解方法。</p>
<p>我们同样定义一个二维数组<code>dp[i][j]</code> ， 表示考虑前 i <strong>种</strong>硬币，凑出金额为 j 的最少硬币数目。</p>
<p>所以每个硬币的面值不再是价值而是背包问题的费用，每种类型的硬币的价值都是 1。</p>
<p>这里出现了与 0/1 背包的<strong>第一个差别</strong>，0/1 背包只有两种选择拿或者不拿，可以理解为拿 0 个和拿 1 个。</p>
<p>而完全背包选择就多了，可以拿 1 个，2 个，3 个等等直到达到最大容量，所以状态转移方程为</p>
<script type="math/tex; mode=display">
dp[i][j] = min(dp[i-1][j], dp[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)</script><p>c 表示第 i 种硬币的面值，也就是费用。</p>
<p>我们发现存在一定的重复计算</p>
<script type="math/tex; mode=display">
dp[i][j-c] = min(dp[i-1][j-c], dp[i-1][j-2*c]+1, f[i-1][j-2*c]+3, ..., f[i-1][j-k*c]+(k+1))</script><p>结合上面两者</p>
<script type="math/tex; mode=display">
dp[i][j] = min(dp[i-1][j],dp[i][j-c]+1)</script><p>分析上面的动态转移方程，我们可以看出来 只考虑前 i 种硬币，凑出金额为 j 的最少硬币数目可以由两种状态得到。</p>
<p>将二维压缩到一维</p>
<script type="math/tex; mode=display">
dp[j] = min(dp[j], dp[j-c] + 1)</script><p>在这里我们可以完全背包和0/1背包的<strong>第二个不同</strong>，完全背包中<code>dp[j-c]</code>不再表示<code>dp[i-1][j-c]</code>而是<code>dp[i][j-c]</code>。为什么要强调这一点呢，因为这会导致我们的编程实现和 0/1 背包出现差异。</p>
<p>在 0/1 背包中，我们如果正序遍历背包容量，会导致<code>dp[i-1][j-c]</code>被<code>dp[i][j-c]</code>覆盖，所以我们要逆序遍历。</p>
<p>而在完全背包问题中，<code>dp[j-c]</code>表示的就是<code>dp[i][j-c]</code>，所以我们要正序遍历背包容量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>当物品个数有限时，我们采取逆序的循环遍历容量，如0/1背包问题。</p>
</li>
<li><p>当物品个数无限是，我们采用顺序的循环，如完全背包问题。</p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>646. 最长数对链</title>
    <url>/2019/11/27/646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/</url>
    <content><![CDATA[<h4 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener">646. 最长数对链</a></h4><p>如何排列 pair 使得 pair 链最长，类似于👉<a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">贪心算法</a>的经典问题-✍️<a href="https://en.wikipedia.org/wiki/Activity_selection_problem" target="_blank" rel="noopener">活动选择问题</a></p>
<p>这类问题的贪心算法就是：</p>
<p>在现有的活动中选择「最早结束」的活动，对应到我们的这个问题，就是选择 pair 中第二位最小的数。</p>
<a id="more"></a>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (pairs == <span class="keyword">null</span> || pairs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = pairs.length;</span><br><span class="line">        Arrays.sort(pairs, <span class="keyword">new</span> Comparator<<span class="keyword">int</span>[]>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] != o2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">int</span> a = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pair : pairs) {</span><br><span class="line">            <span class="keyword">if</span> (pair[<span class="number">0</span>] > a) {</span><br><span class="line">                a = pair[<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解</title>
    <url>/2019/11/26/Leetcode-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span> still works.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>二分查找的各种变形</title>
    <url>/2019/11/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="二分查找，寻找插入的位置"><a href="#二分查找，寻找插入的位置" class="headerlink" title="二分查找，寻找插入的位置"></a>二分查找，寻找插入的位置</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="comment">//开区间</span></span><br><span class="line">    <span class="keyword">while</span> (l < h) {</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == k) {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] > k) {</span><br><span class="line">            h = m;</span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala和Java的版本兼容问题</title>
    <url>/2019/11/26/Scala-and-java-version-compatibility-issues/</url>
    <content><![CDATA[<p><img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/1574740536160.png?raw=true" alt></p>
<p><a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html" target="_blank" rel="noopener">JDK COMPATIBILITY</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 共享变量的若干思考</title>
    <url>/2019/11/26/reflections-on-Spark-shared-variables/</url>
    <content><![CDATA[<p>通常在向 Spark 传递函数时，可以使用 driver programme 中定义的变量，但是集群中运行的每个 tusk 都只会得到这些变量的一份新的副本，更新这些副本的值也不会影响driver programme 中的对应变量。</p>
<p>Spark 的两个共享变量，累加器与广播变量，使用结果聚合与广播这两种常见的通信模式突破了这一限制。<br><a id="more"></a></p>
<h2 id="Accumulator"><a href="#Accumulator" class="headerlink" title="Accumulator"></a>Accumulator</h2><h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><p>第一种共享变量，即累加器，提供了将 worker node 中的值聚合到 driver programme 中的简单语法。</p>
<p>下面的代码展示了一个 accumulator 被用于对一个数组中的元素求和:</p>
<figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line">scala> <span class="keyword">val</span> accum = sc.longAccumulator(<span class="string">"My Accumulator"</span>)</span><br><span class="line">accum: org.apache.spark.util.<span class="type">LongAccumulator</span> = <span class="type">LongAccumulator</span>(id: <span class="number">0</span>, name: <span class="type">Some</span>(<span class="type">My</span> <span class="type">Accumulator</span>), value: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala> sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)).foreach(x => accum.add(x))</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span>/<span class="number">09</span>/<span class="number">29</span> <span class="number">18</span>:<span class="number">41</span>:<span class="number">08</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Tasks</span> finished in <span class="number">0.317106</span> s</span><br><span class="line"></span><br><span class="line">scala> accum.value</span><br><span class="line">res2: <span class="type">Long</span> = <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以通过调用 <code>SparkContext.longAccumulator()</code> 或 <code>SparkContext.doubleAccumulator()</code> 方法创建数值类型的 <code>accumulator</code>（累加器）以分别累加 Long 或 Double 类型的值。集群上正在运行的任务就可以使用 <code>add</code> 方法来累计数值。</p>
<p>注意，worker node 上的 tusk 不能访问累加器的值。从这些任务的角度来看，累加器是一个只写变量。只有 driver program 才可以使用 <code>value</code> 方法读取累加器的值。</p>
<h3 id="累加器与容错"><a href="#累加器与容错" class="headerlink" title="累加器与容错"></a>累加器与容错</h3><p>Spark 会自动重新执行失败的或较慢的仕务来应对有错的或着比较慢的机器。例如，如果对某分区执行 <code>map()</code> 操作的节点失败了，Spark 会在另一个节点上重新运行该任务。即使该节点没有崩溃，而只是处理速度比别的节点慢很多，Spark 也可以抢占式地在另一个节点上启动一个“投机”（speculative）型的任务副本，如果该任务更早结束就可以直接获取结果。即使没有节点失败，Spark有时也需要重新运行任务来获取缓存中被移除出内存的数据。</p>
<p><em>因此最终结果就是同一个函数可能对同一个数据运行了多次。</em></p>
<p>这种情况下累加器要怎么处理呢？</p>
<p>实际结果是，对于要在 action 操作中使用的累加器，Spark只会把每个任务对累加器的修改应用一次。</p>
<p>因此，如果想要一个无论在失败还是重复计算时都绝对可靠的累加器，我们必须把它放在 <code>foreach()</code> 这样的 action 操作中。对于在 RDD  transform 操作中使用的累加器，就不能保证有这种情况了。transform 操作中累加器可能会发生不止一次更新。</p>
<p>举个例子，当一个被缓存下来但是没有经常使用的RDD在第一次从 LRU 缓存中被移除并又被重新用到时，这种非预期的累加器的多次更新就会发生。</p>
<h2 id="Broadcast-Variables"><a href="#Broadcast-Variables" class="headerlink" title="Broadcast Variables"></a>Broadcast Variables</h2><p>Spark 的第二种共享变量是<em>广播变量</em>，它可以让程序高效的向所有的 worker node 发送一个较大的 只读值。比如，你的应用需要向所有的节点发送一个较大的只读查询表，甚至是机器学习算法中的一个很大的特征向量，这个时候广播变量就会很好用了。</p>
<p>如果你对闭包有了解，你会发现，Spark 会自动把闭包中所有引用到的变量发送到 worker node上。这虽然很方便，但也很低效。原因有二：</p>
<ul>
<li>默认的任务发送机制是专门为小任务进行优化的，当发送的共享数据量较大时效率较低</li>
<li>事实上你可能会在多个操作中使用同一个变量，但是Spark会为每个操作分别发送。</li>
</ul>
<p>广播变量通过在一个变量 <code>v</code> 上调用 <code>SparkContext.broadcast(v)</code> 方法来进行创建。广播变量是 <code>v</code> 的一个 wrapper（包装器），可以通过调用 <code>value</code> 方法来访问它的值。代码示例如下:</p>
<figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的 v 指的是 Array(1, 2, 3)</span></span><br><span class="line">scala> <span class="keyword">val</span> broadcastVar = sc.broadcast(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">broadcastVar: org.apache.spark.broadcast.<span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = <span class="type">Broadcast</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala> broadcastVar.value</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下的Spark程序开发环境配置</title>
    <url>/2019/11/25/Spark-program-development-environment-configuration-under-Windows/</url>
    <content><![CDATA[<p>在Windows环境下, 使用IDEA进行Spark程序开发所需的环境配置, 主要是Maven pom文件的配置和Scala SDK的配置。<br><a id="more"></a></p>
<h3 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h3><p>需要配置<code>Maven home directory</code>、<code>User settings file</code>、<code>Local repository</code>、 <code>Import Maven projects automatically</code></p>
<h2 id="IDEA-Maven工程创建与配置"><a href="#IDEA-Maven工程创建与配置" class="headerlink" title="IDEA Maven工程创建与配置"></a>IDEA Maven工程创建与配置</h2><h3 id="配置pom-xml文件"><a href="#配置pom-xml文件" class="headerlink" title="配置pom.xml文件"></a>配置<code>pom.xml</code>文件</h3><p><strong>spark精简版的pom.xml</strong></p>
<p><a href="https://github.com/apache/spark/blob/master/examples/pom.xml" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/examples/pom.xml</a></p>
<p><strong>spark最全版的pom.xml</strong></p>
<p><a href="https://github.com/apache/spark/blob/master/pom.xml" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/pom.xml</a></p>
<p><strong>maven repository</strong></p>
<p><a href="https://mvnrepository.com/search?q=spark" target="_blank" rel="noopener">https://mvnrepository.com/search?q=spark</a></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"><?xml version="1.0" encoding="UTF-8"?></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>></span></span><br><span class="line"></span><br><span class="line">  <span class="tag"><<span class="name">modelVersion</span>></span>4.0.0<span class="tag">modelVersion</span>></span><br><span class="line">  <span class="tag"><<span class="name">packaging</span>></span>war<span class="tag">packaging</span>></span><br><span class="line"></span><br><span class="line">  <span class="tag"><<span class="name">name</span>></span>TestSpark<span class="tag">name</span>></span><br><span class="line">  <span class="tag"><<span class="name">groupId</span>></span>com.kfk.spark<span class="tag">groupId</span>></span><br><span class="line">  <span class="tag"><<span class="name">artifactId</span>></span>TestSpark<span class="tag">artifactId</span>></span><br><span class="line">  <span class="tag"><<span class="name">version</span>></span>1.0-SNAPSHOT<span class="tag">version</span>></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag"><<span class="name">properties</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">scala.version</span>></span>2.11.12<span class="tag">scala.version</span>></span><br><span class="line">    <span class="tag"><<span class="name">scala.binary.version</span>></span>2.11<span class="tag">scala.binary.version</span>></span><br><span class="line">    <span class="tag"><<span class="name">spark.version</span>></span>2.2.0<span class="tag">spark.version</span>></span><br><span class="line">  <span class="tag">properties</span>></span><br><span class="line"></span><br><span class="line">  <span class="tag"><<span class="name">dependencies</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-core_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-streaming_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-sql_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-hive_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-streaming-kafka-0-10_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.hadoop<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>hadoop-client<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>2.6.0<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">  <span class="tag">dependencies</span>></span><br><span class="line"></span><br><span class="line"><span class="tag">project</span>></span><br></pre></td></tr></tbody></table></figure>
<h3 id="导入Scala-SDK"><a href="#导入Scala-SDK" class="headerlink" title="导入Scala SDK"></a>导入<code>Scala SDK</code></h3><p><code>groupId</code>和<code>artifactId</code>被统称为“坐标”是为了保证项目唯一性而提出的</p>
<p><code>groupId</code>一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。举个apache公司的tomcat项目例子：这个项目的<code>groupId</code>是org.apache</p>
<p>artifactId表示这个项目的名称</p>
<p>包结构最好是<code>groupId.artifactId.xxx</code></p>
<h2 id="编写spark程序"><a href="#编写spark程序" class="headerlink" title="编写spark程序"></a>编写spark程序</h2><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spark.test</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.{<span class="type">SparkConf</span>, <span class="type">SparkContext</span>}</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyScalaWordCout</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = {</span><br><span class="line">    <span class="comment">//参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (args.length < <span class="number">2</span>) {</span><br><span class="line">      <span class="type">System</span>.err.println(<span class="string">"Usage: MyWordCout    "</span>)</span><br><span class="line">      <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="keyword">val</span> input=args(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> output=args(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//创建scala版本的SparkContext</span></span><br><span class="line">    <span class="keyword">val</span> conf=<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"myWordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc=<span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="keyword">val</span> lines=sc.textFile(input)</span><br><span class="line">    <span class="comment">//进行相关计算</span></span><br><span class="line">    <span class="keyword">val</span> resultRdd=lines.flatMap(_.split(<span class="string">" "</span>)).map((_,<span class="number">1</span>)).reduceByKey(_+_)</span><br><span class="line">    <span class="comment">//保存结果</span></span><br><span class="line">    resultRdd.saveAsTextFile(output)</span><br><span class="line">    sc.stop()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="打成jar包然后上传到服务器"><a href="#打成jar包然后上传到服务器" class="headerlink" title="打成jar包然后上传到服务器"></a>打成jar包然后上传到服务器</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">bin/spark-submit --master <span class="built_in">local</span>[2] /opt/jars/sparkStu.jar hdfs://bigdata-pro01.kfk.com:9000/user/data/stu.txt</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">./bin/spark-submit \</span><br><span class="line">  --class <main-class> \</main-class></span><br><span class="line">  --master <master-url> \</master-url></span><br><span class="line">  --deploy-mode <deploy-mode> \</deploy-mode></span><br><span class="line">  --conf <key>=<value> \</value></key></span><br><span class="line">  ... <span class="comment"># other options</span></span><br><span class="line">  <application-jar> \</application-jar></span><br><span class="line">  [application-arguments]</span><br></pre></td></tr></tbody></table></figure>
<p>Some of the commonly used options are:</p>
<blockquote>
<ul>
<li><code>--class</code>: The entry point for your application (e.g. <code>org.apache.spark.examples.SparkPi</code>)</li>
<li><code>--master</code>: The <a href="https://spark.apache.org/docs/latest/submitting-applications.html#master-urls" target="_blank" rel="noopener">master URL</a> for the cluster (e.g. <code>spark://23.195.26.187:7077</code>)</li>
<li><code>--deploy-mode</code>: Whether to deploy your driver on the worker nodes (<code>cluster</code>) or locally as an external client (<code>client</code>) (default: <code>client</code>) <strong>†</strong></li>
<li><code>--conf</code>: Arbitrary Spark configuration property in key=value format. For values that contain spaces wrap “key=value” in quotes (as shown).</li>
<li><code>application-jar</code>: Path to a bundled jar including your application and all dependencies. The URL must be globally visible inside of your cluster, for instance, an <code>hdfs://</code> path or a <code>file://</code> path that is present on all nodes.</li>
<li><code>application-arguments</code>: Arguments passed to the main method of your main class, if any</li>
</ul>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2019/11/25/first-blog/</url>
    <content><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>昨天花了一些时间搭建了 hexo 的框架，打算慢慢的从知乎转移到个人博客了。</p>
<p>为什么想要写博客呢，一方面是想要记录自己的成长，看着自己学会、总结的东西越来越多，还是很有成就感的；另一方面是想要留下点东西，帮助别人吧，把自己踩过的坑，走过的弯路以及经验分享给别人吧。</p>
<p>写博客是一个慢活，得精雕细琢，这对于我这个急性子是一个挺大的挑战。希望写博客能帮我客服一下这个毛病吧。</p>
<p>最后的最后希望，我能一直坚持下去，不断的输入和不断的输出。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
