<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>专业书籍备忘录</title>
    <url>/2019/12/05/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>从Comparable到compareTo方法</title>
    <url>/2019/12/05/%E4%BB%8EComparable%E5%88%B0compareTo%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天刷LeetCode <a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">179. 最大数</a> 需要用到 String 类型的排序问题，就具体看了一下 Java 的实现方法</p>
<p>String 是实现了 Comparable 接口，Comparable 接口里面只有一个方法就是 compareTo 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>{xxx}</span><br></pre></td></tr></tbody></table></figure>
<p>我们来看一下文档说明</p>
<blockquote>
<p>按字典顺序比较两个字符串。比较是基于字符串中每个字符的 Unicode 值。</p>
<p>如果本身字符串对象的字典序在参数字符串之前返回负整数，之后返回正整数，相同返回 0。</p>
</blockquote>
<p>字典序是什么，返回值是怎么确定的呢？</p>
<blockquote>
<p>如果两个字符串字典序不同，则它们</p>
<ul>
<li>要么在某个索引处具有不同的字符（索引必须是两个字符串的有效索引），</li>
<li>要么它们的长度不同</li>
<li>或者以上两者都存在</li>
</ul>
<p>返回值确定如下:</p>
<ul>
<li>如果它们在一个或多个索引位置具有不同的字符，假设 k 表示第一个不相同字符，返回两个字符的差 <code>this.charAt(k)-anotherString .charAt(k)</code></li>
<li>如果没有字符不同，则按字典顺序，较短的字符串在较长的字符串之前，返回 <code>this.length()-anotherString.length()</code></li>
</ul>
</blockquote>
<p>我们拿出一个实现版本看一下它的实现逻辑</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other, <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k < lim; k++) {</span><br><span class="line">        <span class="keyword">if</span> (value[k] != other[k]) {</span><br><span class="line">            <span class="keyword">return</span> getChar(value, k) - getChar(other, k);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从ACID到CAP/BASE</title>
    <url>/2019/12/03/%E4%BB%8EACID%E5%88%B0CAP-BASE/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>2019年11月29日 随笔</title>
    <url>/2019/11/29/2019%E5%B9%B411%E6%9C%8829%E6%97%A5-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>今天北京下了2019年的第一场雪🌨，虽然不大，但是纷纷扬扬的场景还是让人心生欢喜。</p>
<p>这场早来的雪提醒我们，就连之间感觉很新鲜的2019年也都快要过去了。</p>
<p>2019年发生了什么事呢？</p>
<p>仔细想想好像没有发生什么太大的改变，但是好像也有一些什么不同。</p>
<p>在我的印象里2018年的下半年是黑色的，所以，我对着2019年有的不一样的期待，期待能把小论文赶快做出来，期待能学会很多新的技能，期待能去一线互联网公司实习，期待着能多读书等等等等。</p>
<p>好像期待的很多事都没有坚持下来，但是好像也有很多意外的收获，可能这就是人生吧，总不会让你一帆风顺，但是又总会在一些细枝末节的地方给你一点希望。</p>
<p>我总说，种一棵树最好的时间是十年前，其次就是现在，每次说完这句话，我都能重振旗鼓一段时间(至少有半天吧，我也不确定🤣)</p>
<p>最近我发现了一个我很不好的地方，当我的计划被打乱或者受挫的时候，我总是归结于自身之前的计划没有坚持下去，把所有的过错都推到了昨天的自己身上，让现在的自己获得一点心理安慰。</p>
<p>希望发现了这一点的我，能及时的改正一下吧，</p>
<p>人生总会有很多的不如意，晴有时风，阴有时雨，让自己快乐一点吧。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2019/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>待补充</p>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h2><h3 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h3><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p>定义一个二维数组 <code>dp</code> 存储最大价值，其中 <code>dp[i][j]</code> 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<ul>
<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，<code>dp[i][j] = dp[i-1][j]</code>。</li>
<li>第 i 件物品添加到背包中，<code>dp[i][j] = dp[i-1][j-w] + v</code>。</li>
</ul>
<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>
<script type="math/tex; mode=display">
dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v)</script><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        W 表示背包能容纳的最大重量</span></span><br><span class="line"><span class="comment">        N 表示物品的数量</span></span><br><span class="line"><span class="comment">        wiehgts 表示 N 件物品的重量</span></span><br><span class="line"><span class="comment">        value 表示 N 件物品的价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i][j] 表示只放前 i 件的商品，体积不超过 j 的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= n; i++) {< span><br><span class="line">            <span class="keyword">int</span> w = weights[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = values[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j <= w; j++) {< span><br><span class="line">                <span class="keyword">if</span> (j >= w) {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[N][W];</span><br><span class="line">    }</span><br><span class="line">}</span><br></=></span></=></span></pre></td></tr></tbody></table></figure>
<p><strong>我们以下面的物品举例说明求解的过程</strong></p>
<p></p><div align="left"> <img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E8%A1%A8%E5%8D%952.png?raw=true" width="274px" height="141px"> </div><br>下面以四个状态的计算举例<p></p>
<p></p><div align="left"> <img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E8%A1%A8%E5%8D%95.png?raw=true" width="1108px" height="535px"> </div><p></p>
<h3 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h3><p>观察状态转移方程或者填充表格的顺序，我们可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，表示容量为 j 时，可以获得的最大价值。</p>
<script type="math/tex; mode=display">
dp[j] = max(dp[j],dp[j-w]+v)</script><p>值得注意的是，等号左边的<code>dp[j]</code>表示前 i 件商品容量为 j 时可以获得的最大价值，本质上是<code>dp[i][j]</code>；等号右边的<code>dp[j]</code>和<code>dp[j-w]</code>是前 i -1 件商品时容量分别为 j 和 j-w 时获得的最大价值，本质上其实是<code>dp[i-1][j]</code>和<code>dp[i-1][j-w]</code>。</p>
<p>如果我们实现代码的时候，内层循环还是按照容量从小到大循环，就会出现一个问题，就是<code>dp[j-w]</code>表示的不再是<code>dp[i-1][j-w]</code>而是<code>dp[i][j-w]</code>。</p>
<p>所以，我们实现的时候内层循环，要按照容量从大向小来循环。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= n; i++) {< span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j >= <span class="number">1</span>; j--) {</span><br><span class="line">            <span class="keyword">if</span> (j >= w) {</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">}</span><br></=></span></pre></td></tr></tbody></table></figure>
<p>内容参考<a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92?id=_0-1-%e8%83%8c%e5%8c%85" target="_blank" rel="noopener">Leetcode题解/动态规划/0-1-背包</a></p>
<h2 id="二维费用背包问题"><a href="#二维费用背包问题" class="headerlink" title="二维费用背包问题"></a>二维费用背包问题</h2><p>二维费用背包问题本质上只是0/1背包的变形，多添加一种费用。二维费用背包问题是指：</p>
<ul>
<li><p>对于每件物品，具有两种不同的费用和价值（比如一个物品既有体积又有重量，还有选择它得到的价值），选择这件物品必须同时付出这两种代价</p>
</li>
<li><p>对于每种代价都有一个可付出的最大值，也就是背包容量。</p>
</li>
<li><p>问怎样选择物品可以得到最大的价值。</p>
</li>
</ul>
<p>再次以背包问题为例：</p>
<p>有一个容量为 N 、承重为 W 的背包，要用这个背包装下物品的价值最大，这些物品有三个属性：体积 volume、重量 weight 和价值 value。</p>
<p>定义一个三维数组 <code>dp</code> 存储最大价值，其中 <code>dp[i][j][k]</code> 表示前 i 件物品体积不超过 j 重量不超过 k 时能获得的最大价值。</p>
<p>设第 i 件物品体积为 volume、重量为weight、价值为 value，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<ul>
<li>第 i 件物品没添加到背包，体积不超过 j 重量不超过 k 的前 i 件物品的最大价值就是体积不超过 j 重量不超过 k 的前 i-1 件物品的最大价值，<code>dp[i][j][k] = dp[i-1][j][k]</code>。</li>
<li>第 i 件物品添加到背包中，<code>dp[i][j][k] = dp[i-1][j-volume][k-weight] + value</code>。</li>
</ul>
<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>
<script type="math/tex; mode=display">
dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-volume][k-weight] + value)</script><p>同样压缩维度，我们可以获得二维数组下的，状态转移方程</p>
<script type="math/tex; mode=display">
dp[j][k] = max(dp[j][k],dp[j-volume][k-weight] + value)</script><p>我们以 <a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a> 为例说明二维背包的解题过程</p>
<p>在这个问题中，每个字符串对应一个物品，每选择一个字符串就得花费一定量的 0 和 1，每个字符串的价值都是 1，0 和 1的最大容量为 m 和 n 。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         dp[i][j] 表示当 i 个 0 和 j 个 1 时，所能收获的最大价值，也就是最多字符串的个数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) {</span><br><span class="line">            <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < str.length(); i++) {</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(i) == <span class="string">'0'</span>)</span><br><span class="line">                    zero++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    one++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//为什么要逆序遍历，参考0/1 背包的解释。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i >= zero; i--) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j >= one; j--) {</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包问题和 0/1 背包最大的不同，在于<strong>物品是可以重复选择的</strong>。</p>
<p>我们以 <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a> 这道经典题目举例，说明完全背包问题的特点和求解方法。</p>
<p>我们同样定义一个二维数组<code>dp[i][j]</code> ， 表示考虑前 i <strong>种</strong>硬币，凑出金额为 j 的最少硬币数目。</p>
<p>所以每个硬币的面值不再是价值而是背包问题的费用，每种类型的硬币的价值都是 1。</p>
<p>这里出现了与 0/1 背包的<strong>第一个差别</strong>，0/1 背包只有两种选择拿或者不拿，可以理解为拿 0 个和拿 1 个。</p>
<p>而完全背包选择就多了，可以拿 1 个，2 个，3 个等等直到达到最大容量，所以状态转移方程为</p>
<script type="math/tex; mode=display">
dp[i][j] = min(dp[i-1][j], dp[i-1][j-c]+1, f[i-1][j-2*c]+2, ..., f[i-1][j-k*c]+k)</script><p>c 表示第 i 种硬币的面值，也就是费用。</p>
<p>我们发现存在一定的重复计算</p>
<script type="math/tex; mode=display">
dp[i][j-c] = min(dp[i-1][j-c], dp[i-1][j-2*c]+1, f[i-1][j-2*c]+3, ..., f[i-1][j-k*c]+(k+1))</script><p>结合上面两者</p>
<script type="math/tex; mode=display">
dp[i][j] = min(dp[i-1][j],dp[i][j-c]+1)</script><p>分析上面的动态转移方程，我们可以看出来 只考虑前 i 种硬币，凑出金额为 j 的最少硬币数目可以由两种状态得到。</p>
<p>将二维压缩到一维</p>
<script type="math/tex; mode=display">
dp[j] = min(dp[j], dp[j-c] + 1)</script><p>在这里我们可以完全背包和0/1背包的<strong>第二个不同</strong>，完全背包中<code>dp[j-c]</code>不再表示<code>dp[i-1][j-c]</code>而是<code>dp[i][j-c]</code>。为什么要强调这一点呢，因为这会导致我们的编程实现和 0/1 背包出现差异。</p>
<p>在 0/1 背包中，我们如果正序遍历背包容量，会导致<code>dp[i-1][j-c]</code>被<code>dp[i][j-c]</code>覆盖，所以我们要逆序遍历。</p>
<p>而在完全背包问题中，<code>dp[j-c]</code>表示的就是<code>dp[i][j-c]</code>，所以我们要正序遍历背包容量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>当物品个数有限时，我们采取逆序的循环遍历容量，如0/1背包问题。</p>
</li>
<li><p>当物品个数无限是，我们采用顺序的循环，如完全背包问题。</p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>646. 最长数对链</title>
    <url>/2019/11/27/646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/</url>
    <content><![CDATA[<h4 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener">646. 最长数对链</a></h4><p>如何排列 pair 使得 pair 链最长，类似于👉<a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">贪心算法</a>的经典问题-✍️<a href="https://en.wikipedia.org/wiki/Activity_selection_problem" target="_blank" rel="noopener">活动选择问题</a></p>
<p>这类问题的贪心算法就是：</p>
<p>在现有的活动中选择「最早结束」的活动，对应到我们的这个问题，就是选择 pair 中第二位最小的数。</p>
<a id="more"></a>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (pairs == <span class="keyword">null</span> || pairs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = pairs.length;</span><br><span class="line">        Arrays.sort(pairs, <span class="keyword">new</span> Comparator<<span class="keyword">int</span>[]>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] != o2[<span class="number">0</span>]) {</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">int</span> a = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pair : pairs) {</span><br><span class="line">            <span class="keyword">if</span> (pair[<span class="number">0</span>] > a) {</span><br><span class="line">                a = pair[<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解</title>
    <url>/2019/11/26/Leetcode-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span> still works.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>二分查找的各种变形</title>
    <url>/2019/11/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="二分查找，寻找插入的位置"><a href="#二分查找，寻找插入的位置" class="headerlink" title="二分查找，寻找插入的位置"></a>二分查找，寻找插入的位置</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="comment">//开区间</span></span><br><span class="line">    <span class="keyword">while</span> (l < h) {</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == k) {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] > k) {</span><br><span class="line">            h = m;</span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala和Java的版本兼容问题</title>
    <url>/2019/11/26/Scala-and-java-version-compatibility-issues/</url>
    <content><![CDATA[<p><img src="https://github.com/IBITM/ibitm.github.io/blob/master/img/1574740536160.png?raw=true" alt></p>
<p><a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html" target="_blank" rel="noopener">JDK COMPATIBILITY</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 共享变量的若干思考</title>
    <url>/2019/11/26/reflections-on-Spark-shared-variables/</url>
    <content><![CDATA[<p>通常在向 Spark 传递函数时，可以使用 driver programme 中定义的变量，但是集群中运行的每个 tusk 都只会得到这些变量的一份新的副本，更新这些副本的值也不会影响driver programme 中的对应变量。</p>
<p>Spark 的两个共享变量，累加器与广播变量，使用结果聚合与广播这两种常见的通信模式突破了这一限制。<br><a id="more"></a></p>
<h2 id="Accumulator"><a href="#Accumulator" class="headerlink" title="Accumulator"></a>Accumulator</h2><h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><p>第一种共享变量，即累加器，提供了将 worker node 中的值聚合到 driver programme 中的简单语法。</p>
<p>下面的代码展示了一个 accumulator 被用于对一个数组中的元素求和:</p>
<figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line">scala> <span class="keyword">val</span> accum = sc.longAccumulator(<span class="string">"My Accumulator"</span>)</span><br><span class="line">accum: org.apache.spark.util.<span class="type">LongAccumulator</span> = <span class="type">LongAccumulator</span>(id: <span class="number">0</span>, name: <span class="type">Some</span>(<span class="type">My</span> <span class="type">Accumulator</span>), value: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala> sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)).foreach(x => accum.add(x))</span><br><span class="line">...</span><br><span class="line"><span class="number">10</span>/<span class="number">09</span>/<span class="number">29</span> <span class="number">18</span>:<span class="number">41</span>:<span class="number">08</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Tasks</span> finished in <span class="number">0.317106</span> s</span><br><span class="line"></span><br><span class="line">scala> accum.value</span><br><span class="line">res2: <span class="type">Long</span> = <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以通过调用 <code>SparkContext.longAccumulator()</code> 或 <code>SparkContext.doubleAccumulator()</code> 方法创建数值类型的 <code>accumulator</code>（累加器）以分别累加 Long 或 Double 类型的值。集群上正在运行的任务就可以使用 <code>add</code> 方法来累计数值。</p>
<p>注意，worker node 上的 tusk 不能访问累加器的值。从这些任务的角度来看，累加器是一个只写变量。只有 driver program 才可以使用 <code>value</code> 方法读取累加器的值。</p>
<h3 id="累加器与容错"><a href="#累加器与容错" class="headerlink" title="累加器与容错"></a>累加器与容错</h3><p>Spark 会自动重新执行失败的或较慢的仕务来应对有错的或着比较慢的机器。例如，如果对某分区执行 <code>map()</code> 操作的节点失败了，Spark 会在另一个节点上重新运行该任务。即使该节点没有崩溃，而只是处理速度比别的节点慢很多，Spark 也可以抢占式地在另一个节点上启动一个“投机”（speculative）型的任务副本，如果该任务更早结束就可以直接获取结果。即使没有节点失败，Spark有时也需要重新运行任务来获取缓存中被移除出内存的数据。</p>
<p><em>因此最终结果就是同一个函数可能对同一个数据运行了多次。</em></p>
<p>这种情况下累加器要怎么处理呢？</p>
<p>实际结果是，对于要在 action 操作中使用的累加器，Spark只会把每个任务对累加器的修改应用一次。</p>
<p>因此，如果想要一个无论在失败还是重复计算时都绝对可靠的累加器，我们必须把它放在 <code>foreach()</code> 这样的 action 操作中。对于在 RDD  transform 操作中使用的累加器，就不能保证有这种情况了。transform 操作中累加器可能会发生不止一次更新。</p>
<p>举个例子，当一个被缓存下来但是没有经常使用的RDD在第一次从 LRU 缓存中被移除并又被重新用到时，这种非预期的累加器的多次更新就会发生。</p>
<h2 id="Broadcast-Variables"><a href="#Broadcast-Variables" class="headerlink" title="Broadcast Variables"></a>Broadcast Variables</h2><p>Spark 的第二种共享变量是<em>广播变量</em>，它可以让程序高效的向所有的 worker node 发送一个较大的 只读值。比如，你的应用需要向所有的节点发送一个较大的只读查询表，甚至是机器学习算法中的一个很大的特征向量，这个时候广播变量就会很好用了。</p>
<p>如果你对闭包有了解，你会发现，Spark 会自动把闭包中所有引用到的变量发送到 worker node上。这虽然很方便，但也很低效。原因有二：</p>
<ul>
<li>默认的任务发送机制是专门为小任务进行优化的，当发送的共享数据量较大时效率较低</li>
<li>事实上你可能会在多个操作中使用同一个变量，但是Spark会为每个操作分别发送。</li>
</ul>
<p>广播变量通过在一个变量 <code>v</code> 上调用 <code>SparkContext.broadcast(v)</code> 方法来进行创建。广播变量是 <code>v</code> 的一个 wrapper（包装器），可以通过调用 <code>value</code> 方法来访问它的值。代码示例如下:</p>
<figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的 v 指的是 Array(1, 2, 3)</span></span><br><span class="line">scala> <span class="keyword">val</span> broadcastVar = sc.broadcast(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">broadcastVar: org.apache.spark.broadcast.<span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = <span class="type">Broadcast</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala> broadcastVar.value</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下的Spark程序开发环境配置</title>
    <url>/2019/11/25/Spark-program-development-environment-configuration-under-Windows/</url>
    <content><![CDATA[<p>在Windows环境下, 使用IDEA进行Spark程序开发所需的环境配置, 主要是Maven pom文件的配置和Scala SDK的配置。<br><a id="more"></a></p>
<h3 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h3><p>需要配置<code>Maven home directory</code>、<code>User settings file</code>、<code>Local repository</code>、 <code>Import Maven projects automatically</code></p>
<h2 id="IDEA-Maven工程创建与配置"><a href="#IDEA-Maven工程创建与配置" class="headerlink" title="IDEA Maven工程创建与配置"></a>IDEA Maven工程创建与配置</h2><h3 id="配置pom-xml文件"><a href="#配置pom-xml文件" class="headerlink" title="配置pom.xml文件"></a>配置<code>pom.xml</code>文件</h3><p><strong>spark精简版的pom.xml</strong></p>
<p><a href="https://github.com/apache/spark/blob/master/examples/pom.xml" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/examples/pom.xml</a></p>
<p><strong>spark最全版的pom.xml</strong></p>
<p><a href="https://github.com/apache/spark/blob/master/pom.xml" target="_blank" rel="noopener">https://github.com/apache/spark/blob/master/pom.xml</a></p>
<p><strong>maven repository</strong></p>
<p><a href="https://mvnrepository.com/search?q=spark" target="_blank" rel="noopener">https://mvnrepository.com/search?q=spark</a></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"><?xml version="1.0" encoding="UTF-8"?></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>></span></span><br><span class="line"></span><br><span class="line">  <span class="tag"><<span class="name">modelVersion</span>></span>4.0.0<span class="tag">modelVersion</span>></span><br><span class="line">  <span class="tag"><<span class="name">packaging</span>></span>war<span class="tag">packaging</span>></span><br><span class="line"></span><br><span class="line">  <span class="tag"><<span class="name">name</span>></span>TestSpark<span class="tag">name</span>></span><br><span class="line">  <span class="tag"><<span class="name">groupId</span>></span>com.kfk.spark<span class="tag">groupId</span>></span><br><span class="line">  <span class="tag"><<span class="name">artifactId</span>></span>TestSpark<span class="tag">artifactId</span>></span><br><span class="line">  <span class="tag"><<span class="name">version</span>></span>1.0-SNAPSHOT<span class="tag">version</span>></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag"><<span class="name">properties</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">scala.version</span>></span>2.11.12<span class="tag">scala.version</span>></span><br><span class="line">    <span class="tag"><<span class="name">scala.binary.version</span>></span>2.11<span class="tag">scala.binary.version</span>></span><br><span class="line">    <span class="tag"><<span class="name">spark.version</span>></span>2.2.0<span class="tag">spark.version</span>></span><br><span class="line">  <span class="tag">properties</span>></span><br><span class="line"></span><br><span class="line">  <span class="tag"><<span class="name">dependencies</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-core_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-streaming_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-sql_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-hive_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.spark<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spark-streaming-kafka-0-10_${scala.binary.version}<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spark.version}<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.apache.hadoop<span class="tag">groupId</span>></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>hadoop-client<span class="tag">artifactId</span>></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>2.6.0<span class="tag">version</span>></span><br><span class="line">    <span class="tag">dependency</span>></span><br><span class="line">  <span class="tag">dependencies</span>></span><br><span class="line"></span><br><span class="line"><span class="tag">project</span>></span><br></pre></td></tr></tbody></table></figure>
<h3 id="导入Scala-SDK"><a href="#导入Scala-SDK" class="headerlink" title="导入Scala SDK"></a>导入<code>Scala SDK</code></h3><p><code>groupId</code>和<code>artifactId</code>被统称为“坐标”是为了保证项目唯一性而提出的</p>
<p><code>groupId</code>一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。举个apache公司的tomcat项目例子：这个项目的<code>groupId</code>是org.apache</p>
<p>artifactId表示这个项目的名称</p>
<p>包结构最好是<code>groupId.artifactId.xxx</code></p>
<h2 id="编写spark程序"><a href="#编写spark程序" class="headerlink" title="编写spark程序"></a>编写spark程序</h2><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spark.test</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.{<span class="type">SparkConf</span>, <span class="type">SparkContext</span>}</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyScalaWordCout</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = {</span><br><span class="line">    <span class="comment">//参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (args.length < <span class="number">2</span>) {</span><br><span class="line">      <span class="type">System</span>.err.println(<span class="string">"Usage: MyWordCout    "</span>)</span><br><span class="line">      <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="keyword">val</span> input=args(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> output=args(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//创建scala版本的SparkContext</span></span><br><span class="line">    <span class="keyword">val</span> conf=<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"myWordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc=<span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="keyword">val</span> lines=sc.textFile(input)</span><br><span class="line">    <span class="comment">//进行相关计算</span></span><br><span class="line">    <span class="keyword">val</span> resultRdd=lines.flatMap(_.split(<span class="string">" "</span>)).map((_,<span class="number">1</span>)).reduceByKey(_+_)</span><br><span class="line">    <span class="comment">//保存结果</span></span><br><span class="line">    resultRdd.saveAsTextFile(output)</span><br><span class="line">    sc.stop()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="打成jar包然后上传到服务器"><a href="#打成jar包然后上传到服务器" class="headerlink" title="打成jar包然后上传到服务器"></a>打成jar包然后上传到服务器</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">bin/spark-submit --master <span class="built_in">local</span>[2] /opt/jars/sparkStu.jar hdfs://bigdata-pro01.kfk.com:9000/user/data/stu.txt</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">./bin/spark-submit \</span><br><span class="line">  --class <main-class> \</main-class></span><br><span class="line">  --master <master-url> \</master-url></span><br><span class="line">  --deploy-mode <deploy-mode> \</deploy-mode></span><br><span class="line">  --conf <key>=<value> \</value></key></span><br><span class="line">  ... <span class="comment"># other options</span></span><br><span class="line">  <application-jar> \</application-jar></span><br><span class="line">  [application-arguments]</span><br></pre></td></tr></tbody></table></figure>
<p>Some of the commonly used options are:</p>
<blockquote>
<ul>
<li><code>--class</code>: The entry point for your application (e.g. <code>org.apache.spark.examples.SparkPi</code>)</li>
<li><code>--master</code>: The <a href="https://spark.apache.org/docs/latest/submitting-applications.html#master-urls" target="_blank" rel="noopener">master URL</a> for the cluster (e.g. <code>spark://23.195.26.187:7077</code>)</li>
<li><code>--deploy-mode</code>: Whether to deploy your driver on the worker nodes (<code>cluster</code>) or locally as an external client (<code>client</code>) (default: <code>client</code>) <strong>†</strong></li>
<li><code>--conf</code>: Arbitrary Spark configuration property in key=value format. For values that contain spaces wrap “key=value” in quotes (as shown).</li>
<li><code>application-jar</code>: Path to a bundled jar including your application and all dependencies. The URL must be globally visible inside of your cluster, for instance, an <code>hdfs://</code> path or a <code>file://</code> path that is present on all nodes.</li>
<li><code>application-arguments</code>: Arguments passed to the main method of your main class, if any</li>
</ul>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2019/11/25/first-blog/</url>
    <content><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>昨天花了一些时间搭建了 hexo 的框架，打算慢慢的从知乎转移到个人博客了。</p>
<p>为什么想要写博客呢，一方面是想要记录自己的成长，看着自己学会、总结的东西越来越多，还是很有成就感的；另一方面是想要留下点东西，帮助别人吧，把自己踩过的坑，走过的弯路以及经验分享给别人吧。</p>
<p>写博客是一个慢活，得精雕细琢，这对于我这个急性子是一个挺大的挑战。希望写博客能帮我客服一下这个毛病吧。</p>
<p>最后的最后希望，我能一直坚持下去，不断的输入和不断的输出。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
