

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="张潇">
  <meta name="keywords" content="">
  <title>ConcurrentHashMap - 求索之心</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>点滴琢磨</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/banner_img.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-12-12 16:30" pubdate>
        2019年12月12日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      68
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">ConcurrentHashMap</h1>
            
            <div class="markdown-body" id="post-body">
              <h2 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;
    <span class="hljs-keyword">final</span> K key;
    <span class="hljs-keyword">volatile</span> V value;
    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;
&#125;</code></pre>
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap引入了一个分段的概念（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）</p>
<p>Segment 继承自 ReentrantLock。</p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2249069246763182397L</span>;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_SCAN_RETRIES =
        Runtime.getRuntime().availableProcessors() &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">64</span> : <span class="hljs-number">1</span>;

    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;

    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;

    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> threshold;

    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;</code></pre>
<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="hljs-number">16</span>;</code></pre>
<p>从上面的结构我们可以了解到，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。</p>
<p>第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</p>
<p><strong>坏处</strong></p>
<p>这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长</p>
<p><strong>好处</strong></p>
<p>写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上）。</p>
<p>所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</p>
<h3 id="Size方法"><a href="#Size方法" class="headerlink" title="Size方法"></a>Size方法</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The number of elements. Accessed only either within locks</span>
<span class="hljs-comment"> * or among other volatile reads that maintain visibility.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;</code></pre>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Number of unsynchronized retries in size and containsValue</span>
<span class="hljs-comment"> * methods before resorting to locking. This is used to avoid</span>
<span class="hljs-comment"> * unbounded retries if tables undergo continuous modification</span>
<span class="hljs-comment"> * which would make it impossible to obtain an accurate result.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RETRIES_BEFORE_LOCK = <span class="hljs-number">2</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// Try a few times to get accurate count. On failure due to</span>
    <span class="hljs-comment">// continuous async changes in table, resort to locking.</span>
    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="hljs-keyword">this</span>.segments;
    <span class="hljs-keyword">int</span> size;
    <span class="hljs-keyword">boolean</span> overflow; <span class="hljs-comment">// true if size overflows 32 bits</span>
    <span class="hljs-keyword">long</span> sum;         <span class="hljs-comment">// sum of modCounts</span>
    <span class="hljs-keyword">long</span> last = <span class="hljs-number">0L</span>;   <span class="hljs-comment">// previous sum</span>
    <span class="hljs-keyword">int</span> retries = -<span class="hljs-number">1</span>; <span class="hljs-comment">// first iteration isn&#x27;t retry</span>
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">for</span> (;;) &#123;
            <span class="hljs-comment">// 超过尝试次数，则对每个 Segment 加锁</span>
            <span class="hljs-keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); <span class="hljs-comment">// force creation</span>
            &#125;
            sum = <span class="hljs-number">0L</span>;
            size = <span class="hljs-number">0</span>;
            overflow = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j) &#123;
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                <span class="hljs-keyword">if</span> (seg != <span class="hljs-keyword">null</span>) &#123;
                    sum += seg.modCount;
                    <span class="hljs-keyword">int</span> c = seg.count;
                    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || (size += c) &lt; <span class="hljs-number">0</span>)
                        overflow = <span class="hljs-keyword">true</span>;
                &#125;
            &#125;
            <span class="hljs-comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span>
            <span class="hljs-keyword">if</span> (sum == last)
                <span class="hljs-keyword">break</span>;
            last = sum;
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> overflow ? Integer.MAX_VALUE : size;
&#125;</code></pre>
<h2 id="二、JDK-8"><a href="#二、JDK-8" class="headerlink" title="二、JDK 8"></a>二、JDK 8</h2><p>JDK8 中彻底放弃了 Segment 转而采用的是 Node ，其设计思想也不再是 JDK7 中的分段锁思想。</p>
<p>在 JDK8 中 ConcurrentHashMap 利用 CAS + Synchronized 来确保线程安全，它的底层数据结构依然是数组+链表+红黑树。</p>
<h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><pre><code class="hljs java"><span class="hljs-comment">// ConcurrentHashMap核心数组</span>
<span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">16</span>;

<span class="hljs-comment">// 扩容时才会用的一个临时数组</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 表初始化和大小调整控件</span>
<span class="hljs-comment"> * -1 表示正在初始化</span>
<span class="hljs-comment"> * -n 表示有n-1的线程正在扩容.  </span>
<span class="hljs-comment"> * 当 table 为空时, 用来存储要初始化的表的值的大小</span>
<span class="hljs-comment"> * 当 table 已经初始化以后，表示用来调整表大小的值</span>
<span class="hljs-comment"> * 总之，sizeCtl 为正和为负表示截然不同的概念</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;

<span class="hljs-comment">// resize的时候下一个需要处理的元素下标为index=transferIndex-1</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> transferIndex;

<span class="hljs-comment">// 通过CAS无锁更新，ConcurrentHashMap元素总数，但不是准确值</span>
<span class="hljs-comment">// 因为多个线程同时更新会导致部分线程更新失败，失败时会将元素数目变化存储在counterCells中</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> baseCount;

<span class="hljs-comment">// resize或者创建CounterCells时的一个标志位</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;

<span class="hljs-comment">// 用于存储元素变动</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> CounterCell[] counterCells;</code></pre>
<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="Unsafe-compareAndSwapXXX-方法"><a href="#Unsafe-compareAndSwapXXX-方法" class="headerlink" title="Unsafe.compareAndSwapXXX 方法"></a>Unsafe.compareAndSwapXXX 方法</h4><p><code>Unsafe.compareAndSwapXXX()</code> 方法是 sun.misc.Unsafe 类中的方法，因为在 ConcurrentHashMap 中大量使用了这些方法。其声明如下：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapXXX</span><span class="hljs-params">(type1 object, type2 offset, type4 expect, type5 update)</span></span>;</code></pre>
<p>方法的伪逻辑如下：</p>
<pre><code class="hljs java"><span class="hljs-keyword">if</span> (object[offset].value equal expect) &#123;
    object[offset].value = update;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125; <span class="hljs-keyword">else</span> 
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</code></pre>
<p>CAS方法都是native方法，可以保证原子性，并且效率比synchronized高。 </p>
<p>关于CAS方法的原理，建议参考一下两篇博客，强烈推荐</p>
<p><a target="_blank" rel="noopener" href="http://www.dataguru.cn/java-865024-1-1.html">http://www.dataguru.cn/java-865024-1-1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Mainz/p/3546347.html">https://www.cnblogs.com/Mainz/p/3546347.html</a></p>
<h4 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h4><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_BITS = <span class="hljs-number">0x7fffffff</span>; <span class="hljs-comment">// usable bits of normal node hash</span>
<span class="hljs-keyword">int</span> hash = spread(key.hashCode());

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">spread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;
    <span class="hljs-keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)) &amp; HASH_BITS;
&#125;</code></pre>
<p>h ^ (h &gt;&gt;&gt; 16) 在计算 hash 的时候 key.hashCode() 的高位也参与运算，这部分跟 HashMap 计算方法一致，不同的是 h ^ (h &gt;&gt;&gt; 16) 计算结果 &amp; 上 0x7fffffff ，从而保证结果一定为正整数。获得 hash 之后，通过hash &amp; (n -1)计算下标。</p>
<p>为什么要多添加一个与操作呢，看后面的注释</p>
<blockquote>
<p>usable bits of normal node hash</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MOVED     = -<span class="hljs-number">1</span>; <span class="hljs-comment">// hash for forwarding nodes</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEBIN   = -<span class="hljs-number">2</span>; <span class="hljs-comment">// hash for roots of trees</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RESERVED  = -<span class="hljs-number">3</span>; <span class="hljs-comment">// hash for transient reservations</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_BITS = <span class="hljs-number">0x7fffffff</span>; <span class="hljs-comment">// usable bits of normal node hash</span></code></pre>
<p>ConcurrentHashMap 中的元素节点总结一下有这么几种可能：</p>
<ul>
<li><p>null </p>
</li>
<li><p>Node<K, v> 普通节点，可以组成单向链表，hash &gt; 0</K,></p>
</li>
<li><p>TreeBin<K,V> 红黑树节点，TreeBin 是对 TreeNode 的封装，其 hash 为 TREEBIN = -2。</K,V></p>
<p>HashMap 和 ConcurrentHashMap 的 TreeNode 实现并不相同。</p>
<p>在 HashMap 中 TreeNode 封装了红黑树所有的操作方法，而 ConcurrentHashMap 中红黑树操作的方法都封装在 TreeBin 中，TreeBin 相当于一个红黑树容器，容器中的红黑树节点为 TreeNode 。</p>
<p>HashMap 可以直接在 tab[i] 存入 TreeNode ，而 ConCurrentHashMap 只能在 tab[i] 存入 TreeBin 。</p>
</li>
<li><p>ForwardingNode<K,V> key 和 value 都为 null 的一个特殊节点，用于 resize 操作填充已经完成迁移操作的节点。FrowardingNode 的hash在初始化的时候被置成MOVED = -1</K,V></p>
<p>在 resize 过程中当发现 tab[i] 上是 ForwardingNode 的时候（通过hash判断）就可知 tab[i] 已经迁移完了，直接跳过该节点去处理其它节点。</p>
<p>ConcurrentHashMap禁止 node 的 key 或 value 为 null 或许跟该节点的存在也是有一定关系的。</p>
</li>
<li><p>ReservationNode<K,V>只在 compute 和 computeIfAbsent 中使用，其hash为RESERVED = -3</K,V></p>
</li>
</ul>
<p>从上面的总结可以看出普通节点hash为正整数是有意义的，hash &gt; 0是判断该节点是否为链表节点（普通节点）的一个重要依据。</p>
<h4 id="get-set-update-tab-i-方法"><a href="#get-set-update-tab-i-方法" class="headerlink" title="get/set/update tab[i] 方法"></a>get/set/update tab[i] 方法</h4><pre><code class="hljs java"><span class="hljs-comment">// 获取tab[i]节点</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);
&#125;

<span class="hljs-comment">// compare and swap tab[i]，期望值是c，tab[i].value == c ? tab[i] = v : return false</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;
    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);
&#125;

<span class="hljs-comment">// 设置tab[i] = v</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;
    U.putObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);
&#125;
</code></pre>
<h4 id="size-方法"><a href="#size-方法" class="headerlink" title="size() 方法"></a>size() 方法</h4><p>ConcurrentHashMap中baseCount用于保存tab中元素总数，但是并不准确，因为多线程同时增删改，会导致baseCount修改失败，此时会将元素变动存储于counterCells数组内。</p>
<p>当需要统计当前的size的时候，除了要统计baseCount之外，还需要统计counterCells中的元素变化。</p>
<p>值得一提的是即使如此，统计出来的依旧不是当前tab中元素的准确值，在多线程环境下统计前后并不能stop the world暂停线程操作，因此无法保证准确性。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">long</span> n = sumCount();
    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> : (n &gt; (<span class="hljs-keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="hljs-keyword">int</span>)n);
&#125;

<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sumCount</span><span class="hljs-params">()</span> </span>&#123;
    CounterCell[] as = counterCells; 
    CounterCell a;
    <span class="hljs-keyword">long</span> sum = baseCount;
    <span class="hljs-comment">// 除了baseCount以外，部分元素变化存储在counterCells数组中</span>
    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// 遍历数组累加获得结果</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;
            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)
                sum += a.value;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> sum;
&#125;
</code></pre>
<h4 id="put-putIfAbsent方法"><a href="#put-putIfAbsent方法" class="headerlink" title="put/putIfAbsent方法"></a>put/putIfAbsent方法</h4><p>现在对put(putVal)方法做一个总结:</p>
<ol>
<li>如果待插入的键值对中 key 或 value 为 null，抛出异常，结束。否则执行2</li>
<li>如果 table 为 null，则进行初始化操作 initTable()，否则执行3</li>
<li>如果 table[i] 为空，则用 CAS 在 table[i] 头结点直接插入，如果 CAS 执行成功，退出插入操作，执行步骤 7；如果 CAS 失败,则说明有其他节点已经插入，执行4</li>
<li>此时判断，hash 值是否为 MOVED(-1)，如果是则说明其他有其他线程在执行扩容操作，帮助他们一起扩容，来提高性能。如果没有在扩容,那么执行5</li>
<li>判断 hash 的值，如果&gt;=0，则在链表合适的位置插入，否则，查看 table[i] 是否是红黑树结构，如果是，则在红黑树适当位置插入。到此时，值对已经顺利插入，接下来执行6</li>
<li>如果 table[i] 节点数binCount不为0，判断它此时的状态,是否需要转变为红黑树</li>
<li>执行 addcount(1L, binCount)</li>
</ol>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    <span class="hljs-comment">// 核心是调用putVal方法</span>
    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">false</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    <span class="hljs-comment">// 如果key存在就不更新value</span>
    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">true</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;
    <span class="hljs-comment">// key或value 为null都是不允许的，因为Forwarding Node就是key和value都为null，是用作标志位的。</span>
    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-comment">// 根据key计算hash值，有了hash就可以计算下标了</span>
    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());
    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 可能需要初始化或扩容，因此一次未必能完成插入操作，所以添加上for循环</span>
    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;
        Node&lt;K,V&gt; f;  <span class="hljs-comment">//用来存储要插入的键值对</span>
        <span class="hljs-comment">// i 表示要插入的下标, fh 表示要要插入的键值对的 hash 值</span>
        <span class="hljs-keyword">int</span> n, i, fh; 
        <span class="hljs-comment">// 表还没有初始化，先初始化，lazily initialized</span>
        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
            tab = initTable();
        <span class="hljs-comment">// 根据hash计算应该插入的index</span>
        <span class="hljs-comment">// table[i]为空,用CAS在table[i]头结点直接插入,退出插入操作;</span>
        <span class="hljs-comment">// 如果CAS失败,则有其他节点已经插入,继续下一步</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))
                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>
        &#125;
        <span class="hljs-comment">// MOVED for forwarding nodes</span>
        <span class="hljs-comment">// 说明f为ForwardingNode，只有扩容的时候才会有ForwardingNode出现在tab中，因此可以断定该tab正在进行扩容</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)  
            <span class="hljs-comment">// 协助扩容            </span>
            tab = helpTransfer(tab, f);   
        <span class="hljs-keyword">else</span> &#123;
            V oldVal = <span class="hljs-keyword">null</span>;
            <span class="hljs-comment">// 对链表头结点上锁</span>
            <span class="hljs-keyword">synchronized</span> (f) 
            &#123;
                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) 
                &#123;
                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 是链表节点</span>
                        binCount = <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) 
                        &#123;
                            K ek;
                            <span class="hljs-comment">// 遍历链表查找是否包含该元素</span>
                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) 
                            &#123;
                                oldVal = e.val;  <span class="hljs-comment">// 保存旧的值用于当做返回值</span>
                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                    e.val = value;  <span class="hljs-comment">// 替换旧的值为新值</span>
                                <span class="hljs-keyword">break</span>;
                            &#125;
                            Node&lt;K,V&gt; pred = e;
                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) 
                            &#123;
                                <span class="hljs-comment">// 遍历链表，如果一直没找到，则新建一个Node放到链表结尾</span>
                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>);
                                <span class="hljs-keyword">break</span>;
                            &#125;
                        &#125;
                    &#125;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) <span class="hljs-comment">// 是红黑树节点</span>
                    &#123; 
                        Node&lt;K,V&gt; p;
                        binCount = <span class="hljs-number">2</span>;
                        <span class="hljs-comment">// 去红黑树查找该元素，如果没找到就添加，找到了就返回该节点</span>
                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="hljs-keyword">null</span>) &#123;
                            <span class="hljs-comment">// 保存旧的value用于返回</span>
                            oldVal = p.val;
                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                p.val = value; <span class="hljs-comment">// 替换旧的值</span>
                        &#125;
                    &#125;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) 
            &#123;
                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)
                    <span class="hljs-comment">// 链表长度超过阈值（默认为8），则需要将链表转为一棵红黑树</span>
                    treeifyBin(tab, i);
                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)
                    <span class="hljs-comment">// 如果只是替换，并未带来节点的增加则直接返回旧的value即可</span>
                    <span class="hljs-keyword">return</span> oldVal;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// 元素总数加1，并且判断是否需要扩容</span>
    addCount(<span class="hljs-number">1L</span>, binCount);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;
</code></pre>
<h4 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h4><pre><code class="hljs java"><span class="hljs-comment">// check&lt;0不检查resize, check&lt;=1只在没有线程竞争的情况下检查resize</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> check)</span> </span>&#123;
    CounterCell[] as; 
    <span class="hljs-keyword">long</span> b, s;
    <span class="hljs-comment">// counterCells数组不为null       </span>
    <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-keyword">null</span> ||
        <span class="hljs-comment">// CAS更新BASECOUNT失败（有其它线程更新了BASECOUNT，baseCount已经不是最新值）</span>
        !U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) 
    &#123;
        CounterCell a; 
        <span class="hljs-keyword">long</span> v; 
        <span class="hljs-keyword">int</span> m;
        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">// counterCells为null</span>
        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||
            <span class="hljs-comment">// counterCells对应位置为null，这里不是很懂，有没有大神解答下？</span>
            <span class="hljs-comment">// ThreadLocalRandom.getProbe() 获得线程探测值，什么用途？</span>
            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||
            <span class="hljs-comment">// 更新CELLVALUE失败</span>
            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;
            <span class="hljs-comment">// 初始化counterCells</span>
            fullAddCount(x, uncontended);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// counterCells != null 或者 BASECOUNT CAS更新失败都是因为有线程竞争，因此不检查resize</span>
        <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span>;
        <span class="hljs-comment">// 统计下ConcurrentHashMap元素总数    </span>
        s = sumCount();
    &#125;
    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;
        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-keyword">int</span> n, sc;
        <span class="hljs-comment">// 元素总数大于sizeCtl</span>
        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;
            <span class="hljs-comment">// 获取一个resize标志位   </span>
            <span class="hljs-keyword">int</span> rs = resizeStamp(n);
            <span class="hljs-comment">// sizeCtl &lt; 0 表示table正在初始化或者resize</span>
            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> || transferIndex &lt;= <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))
                    transfer(tab, nt);
            &#125;
            <span class="hljs-comment">// 当前线程是第一个发起扩容操作</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))
                transfer(tab, <span class="hljs-keyword">null</span>);
            s = sumCount();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。</span>
<span class="hljs-comment"> * 所以执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，</span>
<span class="hljs-comment"> * 有且只有一个线程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;
    Node&lt;K,V&gt;[] tab; 
    <span class="hljs-keyword">int</span> sc;
    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//sizeCtl 为负值时，表示线程在初始化或者扩容</span>
            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">int</span> n = (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;
                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);
                &#125;
            &#125; <span class="hljs-keyword">finally</span> &#123;
                sizeCtl = sc;
            &#125;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> tab;
&#125;
</code></pre>
<h4 id="resize相关方法：resizeStamp、helpTransfer、transfer"><a href="#resize相关方法：resizeStamp、helpTransfer、transfer" class="headerlink" title="resize相关方法：resizeStamp、helpTransfer、transfer"></a>resize相关方法：resizeStamp、helpTransfer、transfer</h4><pre><code class="hljs java"><span class="hljs-comment">// 返回一个标志位，该标志位经过RESIZE_STAMP_SHIFT左移必定为负数</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">resizeStamp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
    <span class="hljs-comment">// Integer.numberOfLeadingZeros返回n对应32位二进制数左侧0的个数，如9（1001）返回28  </span>
    <span class="hljs-comment">// 1 &lt;&lt; (RESIZE_STAMP_BITS - 1) = 2^15，其中RESIZE_STAMP_BITS固定为16</span>
    <span class="hljs-keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="hljs-number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="hljs-number">1</span>));
&#125;</code></pre>
<p> table是一个链表数组，默认为空，初始化操作延迟到了第一次执行put，默认大小DEFAULT_CAPACITY=16 ,执行扩容后，总为2的n次幂</p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;
    <span class="hljs-keyword">final</span> K key;
    <span class="hljs-keyword">volatile</span> V val;
    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;

    Node(<span class="hljs-keyword">int</span> hash, K key, V val) &#123;
        <span class="hljs-keyword">this</span>.hash = hash;
        <span class="hljs-keyword">this</span>.key = key;
        <span class="hljs-keyword">this</span>.val = val;
    &#125;

    Node(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;
        <span class="hljs-keyword">this</span>(hash, key, val);
        <span class="hljs-keyword">this</span>.next = next;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>     </span>&#123; <span class="hljs-keyword">return</span> key; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>   </span>&#123; <span class="hljs-keyword">return</span> val; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> Helpers.mapEntryToString(key, val);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span> </span>&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;
        Object k, v, u; Map.Entry&lt;?,?&gt; e;
        <span class="hljs-keyword">return</span> ((o <span class="hljs-keyword">instanceof</span> Map.Entry) &amp;&amp;
                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="hljs-keyword">null</span> &amp;&amp;
                (v = e.getValue()) != <span class="hljs-keyword">null</span> &amp;&amp;
                (k == key || k.equals(key)) &amp;&amp;
                (v == (u = val) || v.equals(u)));
    &#125;
</code></pre>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>上面提到，初始化操作发生在第一次put操作，那么多个线程执行put时，如何保证只执行一次初始化呢?</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">false</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-comment">//计算hash值</span>
    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());
    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//开始执行插入操作</span>
    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;
        Node&lt;K,V&gt; f; 
        <span class="hljs-keyword">int</span> n, i, fh;
       <span class="hljs-comment">//如果table为空,执行初始化操作</span>
        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
            tab = initTable();
        <span class="hljs-comment">//table[i]为空,用CAS在table[i]头结点直接插入,退出插入操作;如果CAS失败,则有其他节点已经插入,继续下一步</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,
                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))
                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>
        &#125;
        <span class="hljs-comment">//如果table[i]不为空,且table[i]的hash值为-1,则有其他线程在执行扩容操作,帮助他们一起扩容,提高性能</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
       <span class="hljs-comment">//如果没有在扩容</span>
        <span class="hljs-keyword">else</span> &#123;
            V oldVal = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">synchronized</span> (f) &#123;
                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;
                    <span class="hljs-comment">//fh(table[i])的hash&gt;=0,则此时table[i]为链表结构,找到合适位置插入</span>
                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;
                        binCount = <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                            K ek;
                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;
                                oldVal = e.val;
                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                    e.val = value;
                                <span class="hljs-keyword">break</span>;
                            &#125;
                            Node&lt;K,V&gt; pred = e;
                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;
                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,
                                                          value, <span class="hljs-keyword">null</span>);
                                <span class="hljs-keyword">break</span>;
                            &#125;
                        &#125;
                    &#125;
                    <span class="hljs-comment">//fh(table[i])的hash&lt;0,table[i]为红黑树结构,这个过程采用同步内置锁实现并发</span>
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;
                        Node&lt;K,V&gt; p;
                        binCount = <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != <span class="hljs-keyword">null</span>) &#123;
                            oldVal = p.val;
                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                p.val = value;
                        &#125;
                    &#125;
                &#125;
            &#125;<span class="hljs-comment">//到此时,已将键值对插入到了合适的位置,检查链表长度是否超过阈值,若是,则转变为红黑树结构</span>
            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)
                    <span class="hljs-keyword">return</span> oldVal;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">//count+1,如有必要,则扩容</span>
    addCount(<span class="hljs-number">1L</span>, binCount);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;
</code></pre>
<pre><code class="hljs java"></code></pre>
<p>Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。</p>
<p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p>
<p>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。<br>2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。<br>3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。<br>4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。<br>5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/12/14/2019%20%E5%B9%B4%E5%B9%B4%E5%BA%95%EF%BC%8C%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2019 年年底，关于面试的一些总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/12/12/HashMap/">
                        <span class="hidden-mobile">HashMap</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "ConcurrentHashMap&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>















</body>
</html>
